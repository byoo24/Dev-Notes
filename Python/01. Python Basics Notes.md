# **Python Basic Notes**

# *Table of Contents*

2. [Basics](#basics)
    1. [Keywords](#keywords)
    2. [Falsey Values](#falsey-values)
    3. [Iterators](#iterators)
    4. [Generators](#generators)
3. [Data Structures](#data-structures)
    1. Sequence Types
        1. [Lists](#lists)
        2. [Tuples](#tuples)
        3. [Ranges](#ranges)
    2. Mapping Types
        1. [Dictionaries](#dictionaries)
    3. Set Types
        1. [Set](#set)
        2. [Frozenset](#frozenset)
4. [Classes](#classes)
    1. [Class and Instance Variables](#class-and-instance-variables)
    2. [Inheritance](#inheritance)
    3. [Private Variables](#private-variables)
9. [Methods](#methods)
9. [String Formatting](#string-formatting)
9. [TkInter]
    1. [Pack Geometry Manager](#pack-geometry-manager)
    2. [Grid Geometry Manager](#grid-geomtry-manager)
    3. [Advanced GUI](#advanced-gui)
9. [Blackjack Code](#blackjack-code)





# **Basics**


## *Keywords*
https://www.programiz.com/python-programming/keyword-list


## *Falsey Values*
* False
* None
* 0
* 0.0
* [] *(empty list)*
* () *(empty tuple)*
* '' *(empty string)*
* "" *(empty string)*
* {} *(empty mapping)*


## *Iterators*
https://docs.python.org/3/library/stdtypes.html#iterator-types

When using a for loop, Python is generating an `iterator object` under the hood.

```python
alphabet = "abcdefg"

my_iterator = iter(alphabet)
print(my_iterator)
print(next(my_iterator))
print(next(my_iterator))
print(next(my_iterator))

# output:
# <str_iterator object at 0x1027cf450>
# a
# b
# c


for char in alphabet:
    print(char)

# is the same as:
for char in iter(alphabet):
    print(char)
```



## *Generators*
https://docs.python.org/3/tutorial/classes.html#generators

`Generator`s are a simple and powerful tool for creating iterators. They are written like regular functions but use the `yield` statement whenever they want to return data. Each time `next()` is called on it, the generator resumes where it left off (it remembers all the data values and which statement was last executed). An example shows that generators can be trivially easy to create:

```python
def reverse(data):
    for index in range(len(data)-1, -1, -1):
        yield data[index]


# >>> for char in reverse('golf'):
# ...     print(char)
# ...
# f
# l
# o
# g
```

### Example:
Calculating Pi:

```python
def oddnumbers():
    n = 1
    while True:
        yield n
        n += 2

def pi_series():
    odds = oddnumbers()
    approximation = 0
    while True:
        approximation += (4 / next(odds))
        yield approximation
        approximation -= (4 / next(odds))
        yield approximation

approx_pi = pi_series()

for x in range(10000000):
    print(next(approx_pi))
```

Searching the Filesystem:
```python
import os
import fnmatch

def find_albums(root, artist_name):
    for path, directories, files in os.walk(root):
        for artist in fnmatch.filter(directories, artist_name):
        subdir = os.path.join(path, artist)
        for album_path, albums, _ in os.walk(subdir):
            for album in albums:
                yield os.path.join(album_path, album), album

def find_songs(albums):
    for album in albums:
        for song in os.listdir(album[0]):   # we want the path, not the name of the album
            yield song

album_list = find_albums("music", "black*")
song_list = find_songs(album_list)

for s in song_list:
    print(s)
```



# **Data Structures**
https://docs.python.org/3/tutorial/datastructures.html

# Sequence Types

## *Lists*
https://docs.python.org/3/library/stdtypes.html#lists
https://docs.python.org/3/tutorial/datastructures.html#more-on-lists

Lists are `mutable sequences`, typically used to store collections of homogeneous items (where the precise degree of similarity will vary by application).  Lists may be constructed in several ways:
* Using a pair of square brackets to denote the empty list: `[]`
* Using square brackets, separating items with commas: `[a]`, `[a, b, c]`
* Using a list comprehension: `[x for x in iterable]`
* Using the type constructor: `list() `or `list(iterable)`

```python
even = [2, 4, 6, 8]
odd = [1, 3, 5, 7]

numbers = even + odd

numbers_in_order = sorted(numbers)      # does not mutate, returns new list
numbers.sort()                          # mutates the object
```



## *Tuples*
https://docs.python.org/3/library/stdtypes.html#tuples
https://docs.python.org/3/tutorial/datastructures.html#tuples-and-sequences

Tuples are `immutable sequences`, typically used to store collections of heterogeneous data (such as the 2-tuples produced by the enumerate() built-in).  Tuples may be constructed in a number of ways:

* Using a pair of parentheses to denote the empty tuple: `()`
* Using a trailing comma for a singleton tuple: `a,` or `(a,)`
* Separating items with commas: `a, b, c` or `(a, b, c)`
* Using the tuple() built-in: `tuple()` or `tuple(iterable)`



## *Ranges*
https://docs.python.org/3/library/stdtypes.html#ranges

The range type represents an immutable sequence of numbers and is commonly used for looping a specific number of times in for loops.

* class `range(stop)`
* class `range(start, stop[, step])`



# Mapping Types

## *Dictionaries*
https://docs.python.org/3/library/stdtypes.html#mapping-types-dict
https://docs.python.org/3/tutorial/datastructures.html#dictionaries

A `mapping` object maps `hashable` values to arbitrary objects. Mappings are mutable objects. There is currently only one standard mapping type, the dictionary. (For other containers see the built-in list, set, and tuple classes, and the collections module.)

Dictionaries can be created by placing a comma-separated list of key: value pairs within braces, for example: `{'jack': 4098, 'sjoerd': 4127}` or `{4098: 'jack', 4127: 'sjoerd'}`, or by the `dict` constructor.




# Set Types
https://docs.python.org/3/library/stdtypes.html#set-types-set-frozenset
https://docs.python.org/3/tutorial/datastructures.html#sets

A set object is an unordered collection of distinct `hashable` objects. Common uses include membership testing, removing duplicates from a sequence, and computing mathematical operations such as intersection, union, difference, and symmetric difference.


## *Set*
The `set` type is **mutable** — the contents can be changed using methods like `add()` and `remove()`. Since it is mutable, it has no hash value and cannot be used as either a dictionary key or as an element of another set.

```python
# both are sets:
farm_animals = {"sheep", "cow", "hen"}
wild_animals = set(["lion", "tiger", "panther"])

# set constructor:
even = set(range(0, 40, 2))

squares_tuple = (4, 6, 9, 16, 25)
squares = set(squares_tuple)
```


## *Frozenset*
The `frozenset` type is **immutable** and `hashable` — its contents cannot be altered after it is created; it can therefore be used as a dictionary key or as an element of another set.





# **Classes**
https://docs.python.org/3/tutorial/classes.html

## **Class and Instance Variables**
https://docs.python.org/3/tutorial/classes.html#class-and-instance-variables

* Instance variables are for data unique to each instance
* Class variables are for attributes and methods shared by all instances of the class

```python
class Dog:

    kind = 'canine'         # class variable shared by all instances

    def __init__(self, name):
        self.name = name    # instance variable unique to each instance

>>> d = Dog('Fido')
>>> e = Dog('Buddy')
>>> d.kind                  # shared by all dogs
'canine'
>>> e.kind                  # shared by all dogs
'canine'
>>> d.name                  # unique to d
'Fido'
>>> e.name                  # unique to e
'Buddy'
```



## **Inheritance**
https://docs.python.org/3/tutorial/classes.html#inheritance

```python
class DerivedClassName(BaseClassName):
    <statement-1>
    .
    .
    .
    <statement-N>
```



## **Multiple Inheritance**

```python
class DerivedClassName(Base1, Base2, Base3):
    <statement-1>
    .
    .
    .
    <statement-N>
```



## **Private Variables**
https://docs.python.org/3/tutorial/classes.html#private-variables

“Private” instance variables that cannot be accessed except from inside an object don’t exist in Python. However, there is a convention that is followed by most Python code: a name prefixed with an underscore (e.g. _spam) should be treated as a non-public part of the API (whether it is a function, a method or a data member).

```python
class Mapping:
    def __init__(self, iterable):
        self.items_list = []
        self.__update(iterable)

    def update(self, iterable):
        for item in iterable:
            self.items_list.append(item)

    __update = update   # private copy of original update() method

class MappingSubclass(Mapping):

    def update(self, keys, values):
        # provides new signature for update()
        # but does not break __init__()
        for item in zip(keys, values):
            self.items_list.append(item)
```


= = = = = 








# Methods

```python
import datetime
import pytz

class Account:
    """ Simple account class with balance """

    # Static Method, similar to that of C++'s and Java's static method
    @staticmethod
    def _current_time():
        utc_time = datetime.date.time.utcnow()
        return pytz.utc.localize(utc_time)

    def __init__(self, name, balance):
        self.name = name
        self.balance = balance
        self.transaction_list = []
        print("Account created for " + self.name)
    
    def deposit(self, amount)
        if amount > 0:
            self.balance += amount
            # ...

    
```




# String Formatting

Python3:
```python
age = 24

print("My age is " + str(age) + " years")
# My age is 24 years

print("There are {0} days in {1}, {2}, {3}, {4}, {5}, {6} and {7}".format(31, "January", "March", "May", "July", "August", "October", "December"))
# There are 31 days in January, March, May, July, August, October and December

for i in range(1, 12):
    print("No. {0:2} squared is {1:<4} and cubed is {2:4}".format(i, i**2, i**3))

print("Pi is approximately {0:12.50f}".format(22/7))
```

Python2:
```python
# Deprecated in Python3
print("My age is %d %s, %d %s" % (age, "years", 6, "months"))

print("Pi is approximately %12.50f" % (22/7))
```


# Pack Geometry Manager
```python
import tkinter

mainWindow = tkinter.Tk()

mainWindow.title("Hello World")
mainWindow.geometry('640x480+8+400')

label = tkinter.Label(mainWindow, text="Hello World")
label.pack(side='top')

leftFrame = tkinter.Frame(mainWindow)
leftFrame.pack(side='left', anchor='n', fill=tkinter.Y, expand=False)

canvas = tkinter.Canvas(leftFrame, relief='raised', borderwidth=1)
canvas.pack(side='left', anchor='n')

rightFrame = tkinter.Frame(mainWindow)
rightFrame.pack(side='right', anchor='n', expand=True)
button1 = tkinter.Button(rightFrame, text="button1")
button2 = tkinter.Button(rightFrame, text="button2")
button3 = tkinter.Button(rightFrame, text="button3")
button1.pack(side='top')
button2.pack(side='top')
button3.pack(side='top')

mainWindow.mainloop()
```



# Grid Geometry Manager

```python
import tkinter

mainWindow = tkinter.Tk()

mainWindow.title("Hello World")
mainWindow.geometry('640x480+8+200')

label = tkinter.Label(mainWindow, text="Hello World")
label.grid(row=0, column=0)

leftFrame = tkinter.Frame(mainWindow)
leftFrame.grid(row=1, column=1)

canvas = tkinter.Canvas(leftFrame, relief='raised', borderwidth=1)
canvas.grid(row=1, column=0)

rightFrame = tkinter.Frame(mainWindow)
rightFrame.grid(row=1, column=2, sticky='n')
button1 = tkinter.Button(rightFrame, text="button1")
button2 = tkinter.Button(rightFrame, text="button2")
button3 = tkinter.Button(rightFrame, text="button3")
button1.grid(row=0, column=0)
button2.grid(row=1, column=0)
button3.grid(row=2, column=0)


# configure the columns
mainWindow.columnconfigure(0, weight=1)
mainWindow.columnconfigure(1, weight=1)
mainWindow.grid_columnconfigure(2, weight=1)

leftFrame.config(relief='sunken', borderwidth=1)
rightFrame.config(relief='sunken', borderwidth=1)
leftFrame.grid(sticky='ns')
rightFrame.grid(sticky='new')

rightFrame.columnconfigure(0, weight=1)
button2.grid(sticky='ew')

mainWindow.mainloop()
```



# Advanced GUI
```python
import tkinter
import os

mainWindow = tkinter.Tk()

mainWindow.title("Grid Demo")
mainWindow.geometry('640x480+8+200')
mainWindow['padx'] = 8

label = tkinter.Label(mainWindow, text="Hello World")
label.grid(row=0, column=0, columnspan=3)


# Grid
mainWindow.columnconfigure(0, weight=100)
mainWindow.columnconfigure(1, weight=1)
mainWindow.columnconfigure(2, weight=1000)
mainWindow.columnconfigure(3, weight=600)
mainWindow.columnconfigure(4, weight=1000)

mainWindow.rowconfigure(0, weight=1)
mainWindow.rowconfigure(1, weight=10)
mainWindow.rowconfigure(2, weight=1)
mainWindow.rowconfigure(3, weight=3)
mainWindow.rowconfigure(4, weight=3)


# FileList
fileList = tkinter.Listbox(mainWindow)
fileList.grid(row=1, column=0, sticky='nsew', rowspan=2)
fileList.config(border=2, relief='sunken')

for zone in os.listdir('/usr/bin'): # '/Windows/System32'
	fileList.insert(tkinter.END, zone)



# Scrollbar
listScroll = tkinter.Scrollbar(mainWindow, orient=tkinter.VERTICAL, command=fileList.yview)
listScroll.grid(row=1, column=1, sticky='nsw', rowspan=2)
fileList['yscrollcommand'] = listScroll.set



# Frame for the radio buttons
optionFrame = tkinter.LabelFrame(mainWindow, text="File Details")
optionFrame.grid(row=1, column=2, sticky='ne')

rbValue = tkinter.IntVar()
rbValue.set(1)



# Radio buttons
radio1 = tkinter.Radiobutton(optionFrame, text="Filename", value=1, variable=rbValue)
radio2 = tkinter.Radiobutton(optionFrame, text="Path", value=2, variable=rbValue)
radio3 = tkinter.Radiobutton(optionFrame, text="Timestamp", value=3, variable=rbValue)
radio1.grid(row=0, column=0, sticky='w')
radio2.grid(row=1, column=0, sticky='w')
radio3.grid(row=2, column=0, sticky='w')



# Widget to display the result
resultLabel = tkinter.Label(mainWindow, text="Result")
resultLabel.grid(row=2, column=2, sticky='nw')
result = tkinter.Entry(mainWindow)
result.grid(row=2, column=2, sticky='sw')



# Frame for the time spinners
timeFrame = tkinter.LabelFrame(mainWindow, text="Time")
timeFrame.grid(row=3, column=0, sticky='new')



# Time spinners
hourSpinner = tkinter.Spinbox(timeFrame, width=2, values=tuple(range(0,24)))
minuteSpinner = tkinter.Spinbox(timeFrame, width=2, from_=0, to=59)
secondSpinner = tkinter.Spinbox(timeFrame, width=2, from_=0, to=59)

hourSpinner.grid(row=0, column=0)
tkinter.Label(timeFrame, text=':').grid(row=0, column=1)
minuteSpinner.grid(row=0, column=2)
tkinter.Label(timeFrame, text=':').grid(row=0, column=3)
secondSpinner.grid(row=0, column=4)
timeFrame['padx'] = 36


# Frame for the date spinners
dateFrame = tkinter.Frame(mainWindow)
dateFrame.grid(row=4, column=0, sticky='new')


# Date Labels
dayLabel = tkinter.Label(dateFrame, text="Day")
monthLabel = tkinter.Label(dateFrame, text="Month")
yearLabel = tkinter.Label(dateFrame, text="Year")

dayLabel.grid(row=0, column=0, sticky='w')
monthLabel.grid(row=0, column=1, sticky='w')
yearLabel.grid(row=0, column=2, sticky='w')


# Date Spinners
daySpin = tkinter.Spinbox(dateFrame, width=5, from_=1, to=31)
monthSpin = tkinter.Spinbox(dateFrame, width=5, values=("Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"))
yearSpin = tkinter.Spinbox(dateFrame, width=5, from_=2000, to=2099)
daySpin.grid(row=1, column=0)
monthSpin.grid(row=1, column=1)
yearSpin.grid(row=1, column=2)



# Buttons
okButton = tkinter.Button(mainWindow, text="OK")
cancelButton = tkinter.Button(mainWindow, text="Cancel", command=mainWindow.destroy)
okButton.grid(row=4, column=3, sticky='e')
cancelButton.grid(row=4, column=4, sticky='w')


mainWindow.mainloop()
```



# Functions

```python
def python_food():
print("spam and eggs")
```




# Blackjack Code
```python
import random

try:
	import tkinter
except ImportError:  # python 2
	import Tkinter as tkinter


def load_images(card_images):
	suits = ['heart', 'club', 'diamond', 'spade']
	face_cards = ['jack', 'queen', 'king']

	if tkinter.TkVersion >= 8.6:
		extension = 'png'
	else:
		extension = 'ppm'

	# for each suit, retrieve the image for the cards
	for suit in suits:
		# first the number cards 1 to 10
		for card in range(1, 11):
			name = 'cards/{}_{}.{}'.format(str(card), suit, extension)
			image = tkinter.PhotoImage(file=name)
			card_images.append((card, image,))

		# next the face cards
		for card in face_cards:
			name = 'cards/{}_{}.{}'.format(str(card), suit, extension)
			image = tkinter.PhotoImage(file=name)
			card_images.append((10, image,))


def deal_card(frame):
	# pop the next card off the top of the deck
	next_card = deck.pop(0)
	# and add it to back of the pack
	deck.append(next_card)
	# add the image to a Label and display the label
	tkinter.Label(frame, image=next_card[1], relief='raised').pack(side='left')
	# now return the card's face value
	return next_card


def score_hand(hand):
	# Calculate the total score of all cards in the list.
	# Only one ace can have the value 11, and this will be reduce to 1 if the hand would bust.
	score = 0
	ace = False
	for next_card in hand:
		card_value = next_card[0]
		if card_value == 1 and not ace:
			ace = True
			card_value = 11
		score += card_value
		# if we would bust, check if there is an ace and subtract 10
		if score > 21 and ace:
			score -= 10
			ace = False
	return score


def deal_dealer():
	dealer_score = score_hand(dealer_hand)
	while 0 < dealer_score < 17:
		dealer_hand.append(deal_card(dealer_card_frame))
		dealer_score = score_hand(dealer_hand)
		dealer_score_label.set(dealer_score)

	player_score = score_hand(player_hand)
	if player_score > 21:
		result_text.set("Dealer wins!")
	elif dealer_score > 21 or dealer_score < player_score:
		result_text.set("Player wins!")
	elif dealer_score > player_score:
		result_text.set("Dealer wins!")
	else:
		result_text.set("Draw!")


def deal_player():
	player_hand.append(deal_card(player_card_frame))
	player_score = score_hand(player_hand)

	player_score_label.set(player_score)
	if player_score > 21:
		result_text.set("Dealer Wins!")


def initial_deal():
	deal_player()
	dealer_hand.append(deal_card(dealer_card_frame))
	dealer_score_label.set(score_hand(dealer_hand))
	deal_player()


def new_game():
	global dealer_card_frame
	global player_card_frame
	global dealer_hand
	global player_hand
	# embedded frame to hold the card images
	dealer_card_frame.destroy()
	dealer_card_frame = tkinter.Frame(card_frame, background='green')
	dealer_card_frame.grid(row=0, column=1, sticky='ew', rowspan=2)
	# embedded frame to hold the card images
	player_card_frame = tkinter.Frame(card_frame, background="green")
	player_card_frame.grid(row=2, column=1, sticky='ew', rowspan=2)

	result_text.set("")

	# Create the list to store the dealer's and player's hands
	dealer_hand = []
	player_hand = []
	initial_deal()


def shuffle():
	random.shuffle(deck)


def play():
	initial_deal()
	mainWindow.mainloop()


mainWindow = tkinter.Tk()

# Set up the screen and frames for the dealer and player
mainWindow.title("Black Jack")
mainWindow.geometry("640x480")
mainWindow.configure(background='green')

result_text = tkinter.StringVar()
result = tkinter.Label(mainWindow, textvariable=result_text)
result.grid(row=0, column=0, columnspan=3)

card_frame = tkinter.Frame(mainWindow, relief="sunken", borderwidth=1, background="green")
card_frame.grid(row=1, column=0, sticky='ew', columnspan=3, rowspan=2)

dealer_score_label = tkinter.IntVar()
tkinter.Label(card_frame, text="Dealer", background="green", fg='white').grid(row=0, column=0)
tkinter.Label(card_frame, textvariable=dealer_score_label, background="green", fg="white").grid(row=1, column=0)
# embedded frame to hold the card images
dealer_card_frame = tkinter.Frame(card_frame, background="green")
dealer_card_frame.grid(row=0, column=1, sticky="ew", rowspan=2)

player_score_label = tkinter.IntVar()

tkinter.Label(card_frame, text="Player", background="green", fg="white").grid(row=2, column=0)
tkinter.Label(card_frame, textvariable=player_score_label, background="green", fg="white").grid(row=3, column=0)
# embedded frame to hold the card images
player_card_frame = tkinter.Frame(card_frame, background="green")
player_card_frame.grid(row=2, column=1, sticky='ew', rowspan=2)

button_frame = tkinter.Frame(mainWindow)
button_frame.grid(row=3, column=0, columnspan=3, sticky='w')

dealer_button = tkinter.Button(button_frame, text="Dealer", command=deal_dealer)
dealer_button.grid(row=0, column=0)

player_button = tkinter.Button(button_frame, text="Player", command=deal_player)
player_button.grid(row=0, column=1)

new_game_button = tkinter.Button(button_frame, text="New Game", command=new_game)
new_game_button.grid(row=0, column=2)

shuffle_button = tkinter.Button(button_frame, text="Shuffle", command=shuffle)
shuffle_button.grid(row=0, column=3)

# load cards
cards = []
load_images(cards)
print(cards)
# Create a new deck of cards and shuffle them
deck = list(cards) + list(cards) + list(cards)
shuffle()

# Create the list to store the dealer's and player's hands
dealer_hand = []
player_hand = []

if __name__ == "__main__":
	play()


```