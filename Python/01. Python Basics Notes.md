# **Python Basic Notes**

# *Table of Contents*
0. [Best Practices](#best-practices)
1. [Interactive Help](#interactive-help)
2. [Numbers](#numbers)
3. [Datetimes](#datetimes)
4. [Lists](#lists)
5. [List Comprehensions](#list-comprehensions)
6. [Sets](#sets)
7. [Tuples](#tuples)
8. [Dictionaries](#dictionaries)
9. [Logging](#logging)
10. [Memoization](#memoization)
11. [Random](#random)
12. [CSV](#csv)








1. [Map](#map)
2. [Filter](#filter)
3. [Reduce](#reduce)
4. [Lambda](#lambda)







# Best Practices

## *Executing modules as scripts*

https://docs.python.org/3/tutorial/modules.html#executing-modules-as-scripts

```python
python fibo.py <arguments>
```

Add `__name__ == "__main__"` to the end of the module.

```python
if __name__ == "__main__":
    import sys
    fib(int(sys.argv[1]))
```



# Interactive Help
* `dir()` -> Shoft for "directory"
    * `['__builtins__', '__doc__', '__name__', '__package__']`

```python
dir(__builtins__)
help(hex)
help('modules')

# example:
import math
dir()
['__builtins__', '__doc__', '__name__', '__package__', 'math']
```






# Numbers
Python2: `int`, `long`, `float`, `complex` (whole numbers: int, long)
Python3: `int`, `float`, `complex`

If a number becomes too big, python will auto convert the number. So you don't have to worry about overflow

```python
a = 28
type(a)
# <type 'int'>      <-- python2
# <class 'int'>     <-- python3

import sys
sys.maxint
# 2147483647


# complex number:
z = 2 - 6.1j
type(z)
# <class 'complex'>

z.real
# 2.0
z.imag
# -6.1
```





# Datetimes

```python
import datetime
dir(datetime)
help(datetime.date)

gvf = datetime.date(1959, 1, 31)
print(gvr)
print(gvr.year)
print(gvr.month)
print(gvr.day)

mill = datetime.date(2000, 1, 1)
dt = datetime.timedelta(100)
print(mill + dt)


# Day-name, Month-name Day-#, Year
message = "GVR was born on {:%A, %B %d, %Y}."
print(message.format(gvr))
```





























# Map

`map(func, list)`

```python
temps = [("Berlin", 29), ("Cariro", 36), ("Buenos Aries", 19), ("Los Angeles", 26), ("Tokyo", 27), ("New York", 28), ("Longdon", 22), ("Beijing", 32)]

c_to_f = lambda data: (data[0], (9/5)*data[1] + 32)

list(map(c_to_f, temps))
```


# Filter

```python
import statistics

data = [1.3, 2.7, 0.8, 4.1, 4.3, -0.1]
avg = statistics.mean(data)
>>> 2.183333333

list(filter(lambda x: x > avg, data))
>>> [2.7, 4.1, 4.3]
```


# Reduce
As of python3, reduce has been moved to functools because a `for` loop is more readable

```python
from functools import reduce

data = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]
multiplier = lambda x, y: x*y
reduce(multiplier, data)
>>> 646963230


product = 1
for x in data:
    product = product * x
>>> 646963230
```



# Lambda Expressions

```python
g = lambda x: 3*x + 1
g(2)
```

```python
full_name = lambda fn, ln: fn.strip().title() + " " ln.strip().title()
full_name("    leonhard", "EULER")
>>> 'Leonhard Euler'
```

```python
scifi_authors = ["Isaac Asimov", "Ray Bardbury", "Robert Heinlein", "Arthurs C. Clarke", "Frank Herbert", "Orson Scott Card", "Douglas Adams", "H.G. Wells", "Leigh Brackett"]

scifi_authors.sort(key=lambda name: name.split(" ")[-1].lower())
```

```python
def build_quadratic_function(a, b, c):
    """Returns the function f(x) = ax^2 + bx + c"""
    return lambda x: a*x**2 + b*x + c

f = build_quadratic_function(2, 3, -5)
f(0)        # -5
f(1)        # 0
f(2)        # 9
build_quadratic_function(3, 0, 1)(2)    #13
```








# Sets
https://docs.python.org/3/library/stdtypes.html#set-types-set-frozenset
https://docs.python.org/3/tutorial/datastructures.html#sets

The set type is `mutable`: 
* `add()`
* `remove()` = If the element is not a member, raise a KeyError
* `discard()` = If the element is not a member, do nothing.
* `clear()`


```python
odds = set([1, 3, 5, 7])
evens = set([2, 4, 6, 8, 10])
primes = {2, 3, 5, 7}
composites = {4, 6, 8, 9, 10}

odds.union(evens)
# {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
odds.intersection(primes)
{3, 5, 7}
```


```python
# both are sets:
farm_animals = {"sheep", "cow", "hen"}
wild_animals = set(["lion", "tiger", "panther"])

# set constructor:
even = set(range(0, 40, 2))

squares_tuple = (4, 6, 9, 16, 25)
squares = set(squares_tuple)
```




```python
>>> basket = {'apple', 'orange', 'apple', 'pear', 'orange', 'banana'}
>>> print(basket)                      # show that duplicates have been removed
{'orange', 'banana', 'pear', 'apple'}
>>> 'orange' in basket                 # fast membership testing
True
>>> 'crabgrass' in basket
False

>>> # Demonstrate set operations on unique letters from two words
...
>>> a = set('abracadabra')
>>> b = set('alacazam')
>>> a                                  # unique letters in a
{'a', 'r', 'b', 'c', 'd'}
>>> a - b                              # letters in a but not in b
{'r', 'd', 'b'}
>>> a | b                              # letters in a or b or both
{'a', 'c', 'r', 'd', 'b', 'm', 'z', 'l'}
>>> a & b                              # letters in both a and b
{'a', 'c'}
>>> a ^ b                              # letters in a or b but not both
{'r', 'd', 'b', 'm', 'z', 'l'}
```



## Set Comprehensions:
```python
>>> a = {x for x in 'abracadabra' if x not in 'abc'}
>>> a
{'r', 'd'}
```

## *Frozenset*
The `frozenset` type is **immutable** and `hashable` — its contents cannot be altered after it is created; it can therefore be used as a dictionary key or as an element of another set.















# Lists

https://docs.python.org/3/library/stdtypes.html#lists
https://docs.python.org/3/tutorial/datastructures.html#more-on-lists

Lists are `mutable sequences`. 
* `[]`
* `list()`
* list comprehension: `[x for x in iterable]`

```python
# Slicing
primes = [2 ,3, 5, 7, 11, 13, 17, 19]
primes[2:5]
# [5, 7, 11]

# Concatenation
numbers = [1, 2, 3]
letters = ['a', 'b', 'c']
numbers + letters
# [1, 2, 3, 'a', 'b', 'c']
```



```python
even = [2, 4, 6, 8]
odd = [1, 3, 5, 7]

numbers = even + odd

numbers_in_order = sorted(numbers)      # does not mutate, returns new list
numbers.sort()                          # mutates the object
```


### *Using Lists as Stacks*
```python
>>> stack = [3, 4, 5]
>>> stack.append(6)
>>> stack
[3, 4, 5, 6]
>>> stack.pop()
6
>>> stack
[3, 4, 5]
```


### *Using Lists as Queues*
To implement a queue, use `collections.deque` which was designed to have fast appends and pops from both ends. For example:

```python
>>> from collections import deque
>>> queue = deque(["Eric", "John", "Michael"])
>>> queue.append("Terry")           # Terry arrives
>>> queue.popleft()                 # The first to arrive now leaves
'Eric'
>>> queue.popleft()                 # The second to arrive now leaves
'John'
>>> queue                           # Remaining queue in order of arrival
deque(['Michael', 'Terry'])
```



## List Comprehensions

https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions

[*`expr`* for *`val`* in *`collection`*]

[*`expr`* for *`val`* in *`collection`* if *`<test1>`* and *`<test2>`*]

[*`expr`* for *`val1`* in *`collection1`* and *`val2`* in *`collection2`*]


List of Squares:
```python
squares = [i**2 for i in range(1, 101)]
```

Number of Remainders in a Prime Number:
```python
prime_remainders = [x**2 % p for x in range(0, p)]

# Quadratic Reciprocity
len(prime_remainders) = (p + 1) / 2
```


For and If statement:
```python
movies = ["Star Wars", "Gandhi", ...]

gmovies = [title for title in movies if title.startswith("G")]


movies = [("Citizen Kane", 1941), ("Spirited Away", 2001), ...]

pre2k = [title for (title, year) in movies if year < 2000]
```



Scalar Multiplication:
```python
v = [2, -3, 1]

w = [4*x for x in v]
```


Cartesian Product:
```python
A = [1, 3, 5, 7]
B = [2, 4, 6, 8]

cartesian_product = [(a, b) for a in A for b in B]
```



Example 1:

```python
squares = [number ** 2 for number in range(1,7)]
print(squares)


def centre_text(*args):
	text = "-".join([str(arg) for arg in args])
	left_marge = (80 - len(text)) // 2
	print(" " * left_margin, text)

centre_text("first", "second", 3, 4, "spam")
# you can't use join() on an int.
# with List Comprehension, you can quickly convert it into a str



fussy_meals = [meal for meal in menu if
	("spam" in meal or "eggs" in meal) and not ("bacon" in meal and "sausage" in meal)]
```

Example 2:

```python
squares = list(map(lambda x: x**2, range(10)))
# or, equivalently:
squares = [x**2 for x in range(10)]
```

Example 3:

```python
>>> [(x, y) for x in [1,2,3] for y in [3,1,4] if x != y]
[(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]

# equivalent to:
>>> combs = []
>>> for x in [1,2,3]:
...     for y in [3,1,4]:
...         if x != y:
...             combs.append((x, y))
...
>>> combs
[(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]

```

## *Nested List Comprehensions*

https://docs.python.org/3/tutorial/datastructures.html#nested-list-comprehensions

The following list comprehension will `transpose` rows and columns:

```python
>>> matrix = [
...     [1, 2, 3, 4],
...     [5, 6, 7, 8],
...     [9, 10, 11, 12],
... ]

>>> [[row[i] for row in matrix] for i in range(4)]
[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]
```

In the real world, you should prefer built-in functions to complex flow statements. The `zip()` function would do a great job for this use case:

```python
>>> list(zip(*matrix))
[(1, 5, 9), (2, 6, 10), (3, 7, 11), (4, 8, 12)]
```










# Dictionaries
https://docs.python.org/3/library/stdtypes.html#mapping-types-dict
https://docs.python.org/3/tutorial/datastructures.html#dictionaries

A `mapping` object maps `hashable` values to arbitrary objects. Mappings are `mutable objects`. 
* `{"key": value}`
* `dict(key=value, key=value)` --> constructor
* `get()`
* `keys()`
* `items()`
* `pop()`
* `popitem()`
* `clear()`


```python
loc = post2.get('location', None)

for key in post.keys():
    value = post[key]
    print(key, "=" value)

for key, value in post.items():
    print(key, "=", value)
```




```python
>>> tel = {'jack': 4098, 'sape': 4139}
>>> tel['guido'] = 4127

>>> tel
{'jack': 4098, 'sape': 4139, 'guido': 4127}


>>> del tel['sape']

>>> tel['irv'] = 4127
>>> tel
{'jack': 4098, 'guido': 4127, 'irv': 4127}

>>> list(tel)
['jack', 'guido', 'irv']

>>> sorted(tel)
['guido', 'irv', 'jack']

>>> 'guido' in tel
True
>>> 'jack' not in tel
False
```

## Dict Constructor:
```python
>>> dict([('sape', 4139), ('guido', 4127), ('jack', 4098)])
{'sape': 4139, 'guido': 4127, 'jack': 4098}
```

## Dict Comprehensions:
```python
>>> {x: x**2 for x in (2, 4, 6)}
{2: 4, 4: 16, 6: 36}
```















# Tuples
https://docs.python.org/3/library/stdtypes.html#tuples
https://docs.python.org/3/tutorial/datastructures.html#tuples-and-sequences

Tuples are `immutable sequences`.  
* `()`  --> ('a', ) leave a trailing comma for a single item tuple

```python
# to make tuples:
empty_tuple = ()
tuple1 = ("a",)
tuple2 = ("a", "b")
tuple3 = 1,
tuple4 = 1, 2
```

```python
# (age, country, knows_python)
survey = (27, "Vietnam", True)

age, country, knows_python = survey
```


* Using a pair of parentheses to denote the empty tuple: `()`
* Using a trailing comma for a singleton tuple: `a,` or `(a,)`
* Separating items with commas: `a, b, c` or `(a, b, c)`
* Using the tuple() built-in: `tuple()` or `tuple(iterable)`


```python
>>> t = 12345, 54321, 'hello!'

>>> t
(12345, 54321, 'hello!')

>>> # Tuples may be nested:
... u = t, (1, 2, 3, 4, 5)
>>> u
((12345, 54321, 'hello!'), (1, 2, 3, 4, 5))

>>> # Tuples are immutable:
... t[0] = 88888
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: 'tuple' object does not support item assignment

>>> # but they can contain mutable objects:
... v = ([1, 2, 3], [3, 2, 1])
>>> v
([1, 2, 3], [3, 2, 1])
```










# Logging

Record progress and problems. Loggers will only write messages with a level greater than or equal to the set level.

| Level | Numeric Value |
| --- | ---|
| NOTSET | 0 |
| DEBUG | 10 |
| INFO | 20 |
| WARNING | 30 |
| ERROR | 40 |
| CRITICAL | 50 |

```python
import logging

# Create and configure logger
LOG_FORMAT = "%(levelname)s %(asctime)s - %(message)s"
logging.basicConfig(filename = "E:\\python\\Lumberjack.log",
                    level = logging.DEBUG,
                    format = LOG_FORMAT)
logger = logging.getLogger()

# Test mesasages
logger.debug("This is a harmless debug message.")
logger.info("Just some useful info.")
logger.warning("I'm sorry, but I can't do that, Dave.")
logger.error("Did you just try to divide by zero?")
logger.critical("The entire internet is down!!")
```


Example:
```python
import math

def quadratic_formula(a, b, c):
    """Return the solutions to the equation ax^2 + bx + c = 0."""
    logger.info("quadratic_formula({0}, {1}, {2}".format(a, b, c))

    # Compute the discriminant
    logger.debug("# Compute the discriminant")
    disc = b**2 - 4*a*c

    # Compute the two roots
    logger.debug("# Compute the two roots")
    root1 = (-b + math.sqrt(disc)) / (2*a)
    root2 = (-b - math.sqrt(disc)) / (2*a)

    # Return the roots
    logger.debug("# Return the roots")
    return (root1, root2)

roots = quadratic_formula(1, 0, -4)
print(roots)
```








# Memoization

```python
fibonacci_cache = {}

def fibonacci(n):
    # If we have cached teh value, then return it
    if n in fibonacci_cache:
        return fibonacci_cache[n]

    # Compute the Nth term
    if n == 1 or n == 2:
        value = 1
    elif n > 2:
        value = fibonacci(n-1) + fibonacci(n-2)
    
    # Cache the value and return it
    fobonacci_cache[n] = value
    return value
```


### using built-in lru_cache:

```python
from functools import lru_cache

@lru_cache(maxsize = 1000)
def fibonacci(n):
    # Check that the input is a positive integer
    if type(n) != int:
        raise TypeError("n must be a positive int")
    if n < 1:
        raise ValueError("n must be a positive int")

    if n == 1 or n == 2:
        return 1
    elif n > 2:
        return fibonacci(n-1) + fibonacci(n-2)
```








# Random

* `random()`
* `uniform()`
* `normalvariate(u, o)`       <-- Normal Distribution (aka Bell Curve)
* `randint()`
* `choice()`

```python
import random

# Generate random numbers from interval [3, 7)
# Custom made:
def my_random():
    # Random, scale, shift, return...
    return 4 * random.random() + 3

# Built-in function: (uniform)
for i in range(10):
    print(random.uniform(3, 7))
```

```python
import random

outcomes = ['rock', 'paper', 'scissors']

for i in range(20):
    print(random.choice(outcomes))
```













# CSV

Without CSV module:
```python
path = "F:\data\google_stock_data.csv"
# lines = [line for line in open(path)]
dataset = [line.strip().split(',') for line in open(path)]

# PROBLEM:
# If an entry has a comma
# All data trypes are strings.
```

With CSV module:
```python
import csv
from datetime import datetime

path = "F:\data\google_stock_data.csv"
file = open(path, newline='')
reader = csv.reader(file)

header = next(reader) # The first line is the header
# data = [row for row in reader] # Read the remaining data BUT all data is still type string

data = []
for row in reader:
    # row = [Date, Open, High, Low, Close, Volume, Adj. Close]
    date = datetime.strptime(row[0], '%m/%d/$Y')
    open_price = float(row[1])  # 'open' is a builtin function
    high = float(row[2])
    low = float(row[3])
    close = float(row[4])
    volume = int(row[5])
    adj_close = float(row[6])

    data.append([date, open_price, high, low, close, volume, adj_close])


# Compute and store daily stock returns
returns_path = "F:\data\google_returns.csv"
file = open(returns_path, 'w')
writer = csv.writer(file)
writer.writerow(["Date", "Return"])

for i in range(len(data) - 1):
    todays_row = data[i]
    todays_date = todays_row[0]
    todays_price = todays_row[-1]
    yesterdays_row = data[i+1]
    yesterdays_price = yesterdays_row[-1]

    daily_return = (todays_price - yesterdays_price) / yesterdays_price
    formatted_date = todays_date.strftime('%m/%d/%Y')
    writer.writerow([formatted_date, daily_return])
```










































## *Ranges*
https://docs.python.org/3/library/stdtypes.html#ranges

The range type represents an `immutable sequence of numbers` and is commonly used for looping a specific number of times in for loops.

* class `range(stop)`
* class `range(start, stop[, step])`
























# Input and Output


## Fancier Output Formatting
https://docs.python.org/3/tutorial/inputoutput.html#fancier-output-formatting

To use `formatted string literals`, begin a string with f or F before the opening quotation mark or triple quotation mark. Inside this string, you can write a Python expression between { and } characters that can refer to variables or literal values.

```python
>>> year = 2016
>>> event = 'Referendum'
>>> f'Results of the {year} {event}'
'Results of the 2016 Referendum'
```


The `str.format()` method of strings requires more manual effort. You’ll still use { and } to mark where a variable will be substituted and can provide detailed formatting directives, but you’ll also need to provide the information to be formatted.

```python
>>> yes_votes = 42_572_654
>>> no_votes = 43_132_495
>>> percentage = yes_votes / (yes_votes + no_votes)
>>> '{:-9} YES votes  {:2.2%}'.format(yes_votes, percentage)
' 42572654 YES votes  49.67%'
```



## Formatted String Literals
https://docs.python.org/3/tutorial/inputoutput.html#formatted-string-literals


`Formatted string literals` (also called f-strings for short) let you include the value of Python expressions inside a string by prefixing the string with f or F and writing expressions as `{expression}`.

```python
>>> import math
>>> print(f'The value of pi is approximately {math.pi:.3f}.')
The value of pi is approximately 3.142.
```


Passing an integer after the `':'` will cause that field to be a minimum number of characters wide. This is useful for making columns line up.

```python
>>> table = {'Sjoerd': 4127, 'Jack': 4098, 'Dcab': 7678}
>>> for name, phone in table.items():
...     print(f'{name:10} ==> {phone:10d}')
...
Sjoerd     ==>       4127
Jack       ==>       4098
Dcab       ==>       7678
```



Other modifiers can be used to convert the value before it is formatted. `'!a'` applies `ascii()`, `'!s'` applies `str()`, and `'!r'` applies `repr()`:

```python
>>> animals = 'eels'
>>> print(f'My hovercraft is full of {animals}.')
My hovercraft is full of eels.
>>> print(f'My hovercraft is full of {animals!r}.')
My hovercraft is full of 'eels'.
```



## Reading and Writing Files

`open()` returns a `file object`, and is most commonly used with two arguments: `open(filename, mode)`.

```python
f = open('workfile', 'w')
#
#
f.close()
```

* The first argument is a string containing the filename. 
* The second argument is another string containing a few characters describing the way in which the file will be used. mode can be 
	* 'r' when the file will only be read, 
	* 'w' for only writing (an existing file with the same name will be erased), and 
	* 'a' opens the file for appending; any data written to the file is automatically added to the end. 
	* 'r+' opens the file for both reading and writing.


```python
with open('workfile') as f:
	read_data = f.read()
```


* `readline()` reads a single line from the file; a newline character (`\n`) is left at the end of the string, and is only omitted on the last line of the file if the files doesn't end in a new line.
* For reading lings from a file, you can loop over the file object. This is memory efficient, fast, and leads to simple code:

```python
for line in f:
	print(line, end='')

This is the first line of the file.
Second line of the file
```



## Saving data with JSON

https://docs.python.org/3/tutorial/inputoutput.html#saving-structured-data-with-json

The standard module called `json` can take Python data hierarchies, and convert them to string representations; this process is called `serializing`. Reconstructing the data from the string representation is called `deserializing`.

If you have an object x, you can view its JSON string representation with a simple line of code:

```python
>>> import json
>>> json.dumps([1, 'simple', 'list'])
'[1, "simple", "list"]'
```

Another variant of the `dumps()` function, called `dump()`, simply serializes the object to a `text file`. So if `f` is a `text file` object opened for writing, we can do this:

```python
json.dump(x, f)
```

To decode the object again, if `f` is a `text file` object which has been opened for reading:

```python
x = json.load(f)
```














































# Functions

For more info:
* [Keyword arguments](https://docs.python.org/3/tutorial/controlflow.html#keyword-arguments)
* [Docstrings](https://www.python.org/dev/peps/pep-0257/)
* [Function annotations](https://docs.python.org/3/tutorial/controlflow.html#function-annotations)


```python
class Artist(Musician):		# Inheritance
	"""Basic class to store artist details.

	Attributes:
		name (str): The name of the artist.
		albums (List[Album]): A list of the albums by this artist.
			The list includes only those albums in this collection, it is
			not an exhaustive list of the artist's published albums.
	
	Methods:
		add_album: Use to add a new album to the artist's albums list
	""" 	# Docstring

	def __init__(self, name):
		super().__init__(dob="01/01/1990", nickname="dog")	# Inheritance
		self.name = name
		self.albums = []

	def add_song(self, name: str = self.name, year: str, title: str) -> None:		# Function Annotations
		"""Add a new song to the collection of albums

		This method will add the song to an album in the collection.
		A new album will be created in the collection if it doesn't already exist.

		Args:
			name (str): The name of the album
			year (int): The year the album was produced
			title (str): The title of the song
		"""

		# code
```




## *Keyword Arguments*

https://docs.python.org/3/tutorial/controlflow.html#keyword-arguments

Functions can also be called using keyword arguments of the form kwarg=value. For instance, the following function:

```python
def parrot(voltage, state='a stiff', action='voom', type='Norwegian Blue'):
    print("-- This parrot wouldn't", action, end=' ')
    print("if you put", voltage, "volts through it.")
    print("-- Lovely plumage, the", type)
    print("-- It's", state, "!")

parrot(1000)                                          # 1 positional argument
parrot(voltage=1000)                                  # 1 keyword argument
parrot(voltage=1000000, action='VOOOOOM')             # 2 keyword arguments
parrot(action='VOOOOOM', voltage=1000000)             # 2 keyword arguments
parrot('a million', 'bereft of life', 'jump')         # 3 positional arguments
parrot('a thousand', state='pushing up the daisies')  # 1 positional, 1 keyword
```



### Using Splat:

```python
def cheeseshop(kind, *arguments, **keywords):
    print("-- Do you have any", kind, "?")
    print("-- I'm sorry, we're all out of", kind)
    for arg in arguments:
        print(arg)
    print("-" * 40)
    for kw in keywords:
        print(kw, ":", keywords[kw])
```



## *Arbitary Argument Lists*

https://docs.python.org/3/tutorial/controlflow.html#arbitrary-argument-lists

Finally, the least frequently used option is to specify that a function can be called with an arbitrary number of arguments. These arguments will be wrapped up in a tuple (see Tuples and Sequences). Before the variable number of arguments, zero or more normal arguments may occur.

```python
def write_multiple_items(file, separator, *args):
    file.write(separator.join(args))

>>> def concat(*args, sep="/"):
...     return sep.join(args)
...
>>> concat("earth", "mars", "venus")
'earth/mars/venus'
>>> concat("earth", "mars", "venus", sep=".")
'earth.mars.venus'
```



## *Lambda Expressions*

https://docs.python.org/3/tutorial/controlflow.html#lambda-expressions

Small anonymous functions can be created with the lambda keyword. This function returns the sum of its two arguments: lambda a, b: a+b. Lambda functions can be used wherever function objects are required. They are syntactically restricted to a single expression. Semantically, they are just syntactic sugar for a normal function definition. Like nested function definitions, lambda functions can reference variables from the containing scope:

```python
>>> def make_incrementor(n):
...     return lambda x: x + n
...
>>> f = make_incrementor(42)
>>> f(0)
42
>>> f(1)
43
```



## *Function Annotations*

https://docs.python.org/3/tutorial/controlflow.html#function-annotations

Annotations are stored in the `__annotations__` attribute of the function as a dictionary and have no effect on any other part of the function. Parameter annotations are defined by a colon after the parameter name, followed by an expression evaluating to the value of the annotation. Return annotations are defined by a literal ->, followed by an expression, between the parameter list and the colon denoting the end of the def statement. The following example has a positional argument, a keyword argument, and the return value annotated:

```python
>>> def f(ham: str, eggs: str = 'eggs') -> str:
...     print("Annotations:", f.__annotations__)
...     print("Arguments:", ham, eggs)
...     return ham + ' and ' + eggs
...
>>> f('spam')
Annotations: {'ham': <class 'str'>, 'return': <class 'str'>, 'eggs': <class 'str'>}
Arguments: spam eggs
'spam and eggs'
```



































= = = =


3. [Classes](#classes)
    1. [Class and Instance Variables](#class-and-instance-variables)
    2. [Inheritance](#inheritance)
    3. [Private Variables](#private-variables)
	4. [Getters and Setters](#getters-and-setters)
9. [Methods](#methods)
9. [String Formatting](#string-formatting)
9. [TkInter]
    1. [Pack Geometry Manager](#pack-geometry-manager)
    2. [Grid Geometry Manager](#grid-geomtry-manager)
    3. [Advanced GUI](#advanced-gui)
9. [Blackjack Code](#blackjack-code)





# **Basics**

## *Falsey Values*
* False
* None
* 0
* 0.0
* [] *(empty list)*
* () *(empty tuple)*
* '' *(empty string)*
* "" *(empty string)*
* {} *(empty mapping)*


## *Iterators*
https://docs.python.org/3/library/stdtypes.html#iterator-types

When using a for loop, Python is generating an `iterator object` under the hood.

```python
alphabet = "abcdefg"

my_iterator = iter(alphabet)
print(my_iterator)
print(next(my_iterator))
print(next(my_iterator))
print(next(my_iterator))

# output:
# <str_iterator object at 0x1027cf450>
# a
# b
# c


for char in alphabet:
    print(char)

# is the same as:
for char in iter(alphabet):
    print(char)
```



## *Generators*
https://docs.python.org/3/tutorial/classes.html#generators

`Generator`s are a simple and powerful tool for creating iterators. They are written like regular functions but use the `yield` statement whenever they want to return data. Each time `next()` is called on it, the generator resumes where it left off (it remembers all the data values and which statement was last executed). An example shows that generators can be trivially easy to create:

```python
def reverse(data):
    for index in range(len(data)-1, -1, -1):
        yield data[index]


# >>> for char in reverse('golf'):
# ...     print(char)
# ...
# f
# l
# o
# g
```

### Example:
Calculating Pi:

```python
def oddnumbers():
    n = 1
    while True:
        yield n
        n += 2

def pi_series():
    odds = oddnumbers()
    approximation = 0
    while True:
        approximation += (4 / next(odds))
        yield approximation
        approximation -= (4 / next(odds))
        yield approximation

approx_pi = pi_series()

for x in range(10000000):
    print(next(approx_pi))
```

Searching the Filesystem:
```python
import os
import fnmatch

def find_albums(root, artist_name):
    for path, directories, files in os.walk(root):
        for artist in fnmatch.filter(directories, artist_name):
        subdir = os.path.join(path, artist)
        for album_path, albums, _ in os.walk(subdir):
            for album in albums:
                yield os.path.join(album_path, album), album

def find_songs(albums):
    for album in albums:
        for song in os.listdir(album[0]):   # we want the path, not the name of the album
            yield song

album_list = find_albums("music", "black*")
song_list = find_songs(album_list)

for s in song_list:
    print(s)
```



# **Data Structures**
https://docs.python.org/3/tutorial/datastructures.html

# Sequence Types

## *Lists*
https://docs.python.org/3/library/stdtypes.html#lists
https://docs.python.org/3/tutorial/datastructures.html#more-on-lists

Lists are `mutable sequences`, typically used to store collections of homogeneous items (where the precise degree of similarity will vary by application).  Lists may be constructed in several ways:
* Using a pair of square brackets to denote the empty list: `[]`
* Using square brackets, separating items with commas: `[a]`, `[a, b, c]`
* Using a list comprehension: `[x for x in iterable]`
* Using the type constructor: `list() `or `list(iterable)`

```python
even = [2, 4, 6, 8]
odd = [1, 3, 5, 7]

numbers = even + odd

numbers_in_order = sorted(numbers)      # does not mutate, returns new list
numbers.sort()                          # mutates the object
```







## *Tuples*
https://docs.python.org/3/library/stdtypes.html#tuples
https://docs.python.org/3/tutorial/datastructures.html#tuples-and-sequences

Tuples are `immutable sequences`, typically used to store collections of heterogeneous data (such as the 2-tuples produced by the enumerate() built-in).  Tuples may be constructed in a number of ways:

* Using a pair of parentheses to denote the empty tuple: `()`
* Using a trailing comma for a singleton tuple: `a,` or `(a,)`
* Separating items with commas: `a, b, c` or `(a, b, c)`
* Using the tuple() built-in: `tuple()` or `tuple(iterable)`







# Mapping Types













= = = = = 








# Methods

```python
import datetime
import pytz

class Account:
    """ Simple account class with balance """

    # Static Method, similar to that of C++'s and Java's static method
    @staticmethod
    def _current_time():
        utc_time = datetime.date.time.utcnow()
        return pytz.utc.localize(utc_time)

    def __init__(self, name, balance):
        self.name = name
        self.balance = balance
        self.transaction_list = []
        print("Account created for " + self.name)
    
    def deposit(self, amount)
        if amount > 0:
            self.balance += amount
            # ...

    
```




# String Formatting

Python3:
```python
age = 24

print("My age is " + str(age) + " years")
# My age is 24 years

print("There are {0} days in {1}, {2}, {3}, {4}, {5}, {6} and {7}".format(31, "January", "March", "May", "July", "August", "October", "December"))
# There are 31 days in January, March, May, July, August, October and December

for i in range(1, 12):
    print("No. {0:2} squared is {1:<4} and cubed is {2:4}".format(i, i**2, i**3))

print("Pi is approximately {0:12.50f}".format(22/7))
```

Python2:
```python
# Deprecated in Python3
print("My age is %d %s, %d %s" % (age, "years", 6, "months"))

print("Pi is approximately %12.50f" % (22/7))
```




