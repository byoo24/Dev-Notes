# **Python Basic Notes**

# *Table of Contents*


1. [Functions](#functions)
	1. [Default Argument Values](#default-argument-values)
	2. [Keyword Arguments](#keyword-arguments)
	3. [Arbitary Argument Lists](#arbitary-argument-lists)
	4. [Lambda Expressions](#lambda-expressions)
	5. [Function Annotations](#function-annotations)
2. [Data Structures](#data-structures)
	1. [Lists](#lists)
	2. [List Comprehensions](#list-comprehensions)
	3. [Nested List Comprehensions](#list-comprehensions)
	4. [Tuples](#tuples)
	5. [Sets](#sets)
	6. [Dictionaries](#dictionaries)
3. [Modules](#modules)
	1. [Executing modules as scripts](#modules-as-scripts)
4. [Input and Output](#input-and-output)
	1. [Fancier Output Formatting](#fancier-output-formatting)]
	2. [Formatted String Literals](#formatted-string-literals)
	3. [Reading and Writing Files](#reading-and-writing-files)
	4. [Saving data with JSON](#saving-data-with-json)



# Functions

## *Default Argument Values*

https://docs.python.org/3/tutorial/controlflow.html#default-argument-values

```python
def ask_ok(prompt, retries=4, reminder='Please try again!'):
    while True:
        ok = input(prompt)
        if ok in ('y', 'ye', 'yes'):
            return True
        if ok in ('n', 'no', 'nop', 'nope'):
            return False
        retries = retries - 1
        if retries < 0:
            raise ValueError('invalid user response')
        print(reminder)
```



## *Keyword Arguments*

https://docs.python.org/3/tutorial/controlflow.html#keyword-arguments

Functions can also be called using keyword arguments of the form kwarg=value. For instance, the following function:

```python
def parrot(voltage, state='a stiff', action='voom', type='Norwegian Blue'):
    print("-- This parrot wouldn't", action, end=' ')
    print("if you put", voltage, "volts through it.")
    print("-- Lovely plumage, the", type)
    print("-- It's", state, "!")

parrot(1000)                                          # 1 positional argument
parrot(voltage=1000)                                  # 1 keyword argument
parrot(voltage=1000000, action='VOOOOOM')             # 2 keyword arguments
parrot(action='VOOOOOM', voltage=1000000)             # 2 keyword arguments
parrot('a million', 'bereft of life', 'jump')         # 3 positional arguments
parrot('a thousand', state='pushing up the daisies')  # 1 positional, 1 keyword
```



### Using Splat:

```python
def cheeseshop(kind, *arguments, **keywords):
    print("-- Do you have any", kind, "?")
    print("-- I'm sorry, we're all out of", kind)
    for arg in arguments:
        print(arg)
    print("-" * 40)
    for kw in keywords:
        print(kw, ":", keywords[kw])
```



## *Arbitary Argument Lists*

https://docs.python.org/3/tutorial/controlflow.html#arbitrary-argument-lists

Finally, the least frequently used option is to specify that a function can be called with an arbitrary number of arguments. These arguments will be wrapped up in a tuple (see Tuples and Sequences). Before the variable number of arguments, zero or more normal arguments may occur.

```python
def write_multiple_items(file, separator, *args):
    file.write(separator.join(args))

>>> def concat(*args, sep="/"):
...     return sep.join(args)
...
>>> concat("earth", "mars", "venus")
'earth/mars/venus'
>>> concat("earth", "mars", "venus", sep=".")
'earth.mars.venus'
```



## *Lambda Expressions*

https://docs.python.org/3/tutorial/controlflow.html#lambda-expressions

Small anonymous functions can be created with the lambda keyword. This function returns the sum of its two arguments: lambda a, b: a+b. Lambda functions can be used wherever function objects are required. They are syntactically restricted to a single expression. Semantically, they are just syntactic sugar for a normal function definition. Like nested function definitions, lambda functions can reference variables from the containing scope:

```python
>>> def make_incrementor(n):
...     return lambda x: x + n
...
>>> f = make_incrementor(42)
>>> f(0)
42
>>> f(1)
43
```



## *Function Annotations*

https://docs.python.org/3/tutorial/controlflow.html#function-annotations

Annotations are stored in the `__annotations__` attribute of the function as a dictionary and have no effect on any other part of the function. Parameter annotations are defined by a colon after the parameter name, followed by an expression evaluating to the value of the annotation. Return annotations are defined by a literal ->, followed by an expression, between the parameter list and the colon denoting the end of the def statement. The following example has a positional argument, a keyword argument, and the return value annotated:

```python
>>> def f(ham: str, eggs: str = 'eggs') -> str:
...     print("Annotations:", f.__annotations__)
...     print("Arguments:", ham, eggs)
...     return ham + ' and ' + eggs
...
>>> f('spam')
Annotations: {'ham': <class 'str'>, 'return': <class 'str'>, 'eggs': <class 'str'>}
Arguments: spam eggs
'spam and eggs'
```



# Data Structures



## *Lists*

https://docs.python.org/3/library/stdtypes.html#lists
https://docs.python.org/3/tutorial/datastructures.html#more-on-lists

Lists are `mutable sequences`, typically used to store collections of homogeneous items (where the precise degree of similarity will vary by application).  Lists may be constructed in several ways:
* Using a pair of square brackets to denote the empty list: `[]`
* Using square brackets, separating items with commas: `[a]`, `[a, b, c]`
* Using a list comprehension: `[x for x in iterable]`
* Using the type constructor: `list() `or `list(iterable)`


### *Using Lists as Stacks*

```python
>>> stack = [3, 4, 5]
>>> stack.append(6)
>>> stack
[3, 4, 5, 6]
>>> stack.pop()
6
>>> stack
[3, 4, 5]
```



### *Using Lists as Queues*

To implement a queue, use `collections.deque` which was designed to have fast appends and pops from both ends. For example:

```python
>>> from collections import deque
>>> queue = deque(["Eric", "John", "Michael"])
>>> queue.append("Terry")           # Terry arrives
>>> queue.popleft()                 # The first to arrive now leaves
'Eric'
>>> queue.popleft()                 # The second to arrive now leaves
'John'
>>> queue                           # Remaining queue in order of arrival
deque(['Michael', 'Terry'])
```



## *List Comprehensions*

https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions

```python
squares = list(map(lambda x: x**2, range(10)))
# or, equivalently:
squares = [x**2 for x in range(10)]
```

```python
>>> [(x, y) for x in [1,2,3] for y in [3,1,4] if x != y]
[(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]

# equivalent to:
>>> combs = []
>>> for x in [1,2,3]:
...     for y in [3,1,4]:
...         if x != y:
...             combs.append((x, y))
...
>>> combs
[(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]

```



## *Nested List Comprehensions*
https://docs.python.org/3/tutorial/datastructures.html#nested-list-comprehensions

The following list comprehension will `transpose` rows and columns:

```python
>>> matrix = [
...     [1, 2, 3, 4],
...     [5, 6, 7, 8],
...     [9, 10, 11, 12],
... ]

>>> [[row[i] for row in matrix] for i in range(4)]
[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]
```

In the real world, you should prefer built-in functions to complex flow statements. The `zip()` function would do a great job for this use case:

```python
>>> list(zip(*matrix))
[(1, 5, 9), (2, 6, 10), (3, 7, 11), (4, 8, 12)]
```



## *Tuples*
https://docs.python.org/3/library/stdtypes.html#tuples
https://docs.python.org/3/tutorial/datastructures.html#tuples-and-sequences

Tuples are `immutable sequences`, typically used to store collections of heterogeneous data (such as the 2-tuples produced by the enumerate() built-in).  Tuples may be constructed in a number of ways:

* Using a pair of parentheses to denote the empty tuple: `()`
* Using a trailing comma for a singleton tuple: `a,` or `(a,)`
* Separating items with commas: `a, b, c` or `(a, b, c)`
* Using the tuple() built-in: `tuple()` or `tuple(iterable)`



```python
>>> t = 12345, 54321, 'hello!'
>>> t[0]
12345
>>> t
(12345, 54321, 'hello!')
>>> # Tuples may be nested:
... u = t, (1, 2, 3, 4, 5)
>>> u
((12345, 54321, 'hello!'), (1, 2, 3, 4, 5))
>>> # Tuples are immutable:
... t[0] = 88888
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: 'tuple' object does not support item assignment
>>> # but they can contain mutable objects:
... v = ([1, 2, 3], [3, 2, 1])
>>> v
([1, 2, 3], [3, 2, 1])
```



## *Sets*
https://docs.python.org/3/library/stdtypes.html#set-types-set-frozenset
https://docs.python.org/3/tutorial/datastructures.html#sets

The `set` type is **mutable** — the contents can be changed using methods like `add()` and `remove()`. Since it is mutable, it has no hash value and cannot be used as either a dictionary key or as an element of another set.

```python
>>> basket = {'apple', 'orange', 'apple', 'pear', 'orange', 'banana'}
>>> print(basket)                      # show that duplicates have been removed
{'orange', 'banana', 'pear', 'apple'}
>>> 'orange' in basket                 # fast membership testing
True
>>> 'crabgrass' in basket
False

>>> # Demonstrate set operations on unique letters from two words
...
>>> a = set('abracadabra')
>>> b = set('alacazam')
>>> a                                  # unique letters in a
{'a', 'r', 'b', 'c', 'd'}
>>> a - b                              # letters in a but not in b
{'r', 'd', 'b'}
>>> a | b                              # letters in a or b or both
{'a', 'c', 'r', 'd', 'b', 'm', 'z', 'l'}
>>> a & b                              # letters in both a and b
{'a', 'c'}
>>> a ^ b                              # letters in a or b but not both
{'r', 'd', 'b', 'm', 'z', 'l'}
```



### Set Comprehensions:
```python
>>> a = {x for x in 'abracadabra' if x not in 'abc'}
>>> a
{'r', 'd'}
```



## *Dictionaries*
https://docs.python.org/3/library/stdtypes.html#mapping-types-dict
https://docs.python.org/3/tutorial/datastructures.html#dictionaries

A `mapping` object maps `hashable` values to arbitrary objects. Mappings are mutable objects. There is currently only one standard mapping type, the dictionary. (For other containers see the built-in list, set, and tuple classes, and the collections module.)

Dictionaries can be created by placing a comma-separated list of key: value pairs within braces, for example: `{'jack': 4098, 'sjoerd': 4127}` or `{4098: 'jack', 4127: 'sjoerd'}`, or by the `dict` constructor.


```python
>>> tel = {'jack': 4098, 'sape': 4139}
>>> tel['guido'] = 4127
>>> tel
{'jack': 4098, 'sape': 4139, 'guido': 4127}
>>> tel['jack']
4098
>>> del tel['sape']
>>> tel['irv'] = 4127
>>> tel
{'jack': 4098, 'guido': 4127, 'irv': 4127}
>>> list(tel)
['jack', 'guido', 'irv']
>>> sorted(tel)
['guido', 'irv', 'jack']
>>> 'guido' in tel
True
>>> 'jack' not in tel
False
```



### Dict Constructor:
```python
>>> dict([('sape', 4139), ('guido', 4127), ('jack', 4098)])
{'sape': 4139, 'guido': 4127, 'jack': 4098}
```



### Dict Comprehensions:
```python
>>> {x: x**2 for x in (2, 4, 6)}
{2: 4, 4: 16, 6: 36}
```



# Modules


## Executing modules as scripts
https://docs.python.org/3/tutorial/modules.html#executing-modules-as-scripts




# Input and Output


## Fancier Output Formatting
https://docs.python.org/3/tutorial/inputoutput.html#fancier-output-formatting

To use `formatted string literals`, begin a string with f or F before the opening quotation mark or triple quotation mark. Inside this string, you can write a Python expression between { and } characters that can refer to variables or literal values.

```python
>>> year = 2016
>>> event = 'Referendum'
>>> f'Results of the {year} {event}'
'Results of the 2016 Referendum'
```


The `str.format()` method of strings requires more manual effort. You’ll still use { and } to mark where a variable will be substituted and can provide detailed formatting directives, but you’ll also need to provide the information to be formatted.

```python
>>> yes_votes = 42_572_654
>>> no_votes = 43_132_495
>>> percentage = yes_votes / (yes_votes + no_votes)
>>> '{:-9} YES votes  {:2.2%}'.format(yes_votes, percentage)
' 42572654 YES votes  49.67%'
```



## Formatted String Literals
https://docs.python.org/3/tutorial/inputoutput.html#formatted-string-literals


`Formatted string literals` (also called f-strings for short) let you include the value of Python expressions inside a string by prefixing the string with f or F and writing expressions as `{expression}`.

```python
>>> import math
>>> print(f'The value of pi is approximately {math.pi:.3f}.')
The value of pi is approximately 3.142.
```


Passing an integer after the `':'` will cause that field to be a minimum number of characters wide. This is useful for making columns line up.

```python
>>> table = {'Sjoerd': 4127, 'Jack': 4098, 'Dcab': 7678}
>>> for name, phone in table.items():
...     print(f'{name:10} ==> {phone:10d}')
...
Sjoerd     ==>       4127
Jack       ==>       4098
Dcab       ==>       7678
```



Other modifiers can be used to convert the value before it is formatted. `'!a'` applies `ascii()`, `'!s'` applies `str()`, and `'!r'` applies `repr()`:

```python
>>> animals = 'eels'
>>> print(f'My hovercraft is full of {animals}.')
My hovercraft is full of eels.
>>> print(f'My hovercraft is full of {animals!r}.')
My hovercraft is full of 'eels'.
```



## Reading and Writing Files

`open()` returns a `file object`, and is most commonly used with two arguments: `open(filename, mode)`.

```python
f = open('workfile', 'w')
#
#
f.close()
```

* The first argument is a string containing the filename. 
* The second argument is another string containing a few characters describing the way in which the file will be used. mode can be 
	* 'r' when the file will only be read, 
	* 'w' for only writing (an existing file with the same name will be erased), and 
	* 'a' opens the file for appending; any data written to the file is automatically added to the end. 
	* 'r+' opens the file for both reading and writing.


```python
with open('workfile') as f:
	read_data = f.read()
```


* `readline()` reads a single line from the file; a newline character (`\n`) is left at the end of the string, and is only omitted on the last line of the file if the files doesn't end in a new line.
* For reading lings from a file, you can loop over the file object. This is memory efficient, fast, and leads to simple code:

```python
for line in f:
	print(line, end='')

This is the first line of the file.
Second line of the file
```



## Saving data with JSON

https://docs.python.org/3/tutorial/inputoutput.html#saving-structured-data-with-json

The standard module called `json` can take Python data hierarchies, and convert them to string representations; this process is called `serializing`. Reconstructing the data from the string representation is called `deserializing`.

If you have an object x, you can view its JSON string representation with a simple line of code:

```python
>>> import json
>>> json.dumps([1, 'simple', 'list'])
'[1, "simple", "list"]'
```

Another variant of the `dumps()` function, called `dump()`, simply serializes the object to a `text file`. So if `f` is a `text file` object opened for writing, we can do this:

```python
json.dump(x, f)
```

To decode the object again, if `f` is a `text file` object which has been opened for reading:

```python
x = json.load(f)
```











































= = = =


3. [Classes](#classes)
    1. [Class and Instance Variables](#class-and-instance-variables)
    2. [Inheritance](#inheritance)
    3. [Private Variables](#private-variables)
	4. [Getters and Setters](#getters-and-setters)
9. [Methods](#methods)
9. [String Formatting](#string-formatting)
9. [TkInter]
    1. [Pack Geometry Manager](#pack-geometry-manager)
    2. [Grid Geometry Manager](#grid-geomtry-manager)
    3. [Advanced GUI](#advanced-gui)
9. [Blackjack Code](#blackjack-code)





# **Basics**

## *Falsey Values*
* False
* None
* 0
* 0.0
* [] *(empty list)*
* () *(empty tuple)*
* '' *(empty string)*
* "" *(empty string)*
* {} *(empty mapping)*


## *Iterators*
https://docs.python.org/3/library/stdtypes.html#iterator-types

When using a for loop, Python is generating an `iterator object` under the hood.

```python
alphabet = "abcdefg"

my_iterator = iter(alphabet)
print(my_iterator)
print(next(my_iterator))
print(next(my_iterator))
print(next(my_iterator))

# output:
# <str_iterator object at 0x1027cf450>
# a
# b
# c


for char in alphabet:
    print(char)

# is the same as:
for char in iter(alphabet):
    print(char)
```



## *Generators*
https://docs.python.org/3/tutorial/classes.html#generators

`Generator`s are a simple and powerful tool for creating iterators. They are written like regular functions but use the `yield` statement whenever they want to return data. Each time `next()` is called on it, the generator resumes where it left off (it remembers all the data values and which statement was last executed). An example shows that generators can be trivially easy to create:

```python
def reverse(data):
    for index in range(len(data)-1, -1, -1):
        yield data[index]


# >>> for char in reverse('golf'):
# ...     print(char)
# ...
# f
# l
# o
# g
```

### Example:
Calculating Pi:

```python
def oddnumbers():
    n = 1
    while True:
        yield n
        n += 2

def pi_series():
    odds = oddnumbers()
    approximation = 0
    while True:
        approximation += (4 / next(odds))
        yield approximation
        approximation -= (4 / next(odds))
        yield approximation

approx_pi = pi_series()

for x in range(10000000):
    print(next(approx_pi))
```

Searching the Filesystem:
```python
import os
import fnmatch

def find_albums(root, artist_name):
    for path, directories, files in os.walk(root):
        for artist in fnmatch.filter(directories, artist_name):
        subdir = os.path.join(path, artist)
        for album_path, albums, _ in os.walk(subdir):
            for album in albums:
                yield os.path.join(album_path, album), album

def find_songs(albums):
    for album in albums:
        for song in os.listdir(album[0]):   # we want the path, not the name of the album
            yield song

album_list = find_albums("music", "black*")
song_list = find_songs(album_list)

for s in song_list:
    print(s)
```



# **Data Structures**
https://docs.python.org/3/tutorial/datastructures.html

# Sequence Types

## *Lists*
https://docs.python.org/3/library/stdtypes.html#lists
https://docs.python.org/3/tutorial/datastructures.html#more-on-lists

Lists are `mutable sequences`, typically used to store collections of homogeneous items (where the precise degree of similarity will vary by application).  Lists may be constructed in several ways:
* Using a pair of square brackets to denote the empty list: `[]`
* Using square brackets, separating items with commas: `[a]`, `[a, b, c]`
* Using a list comprehension: `[x for x in iterable]`
* Using the type constructor: `list() `or `list(iterable)`

```python
even = [2, 4, 6, 8]
odd = [1, 3, 5, 7]

numbers = even + odd

numbers_in_order = sorted(numbers)      # does not mutate, returns new list
numbers.sort()                          # mutates the object
```




## *List Comprehensions*
https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions

```python
squares = [number ** 2 for number in range(1,7)]
print(squares)


def centre_text(*args):
	text = "-".join([str(arg) for arg in args])
	left_marge = (80 - len(text)) // 2
	print(" " * left_margin, text)

centre_text("first", "second", 3, 4, "spam")
# you can't use join() on an int.
# with List Comprehension, you can quickly convert it into a str



fussy_meals = [meal for meal in menu if
	("spam" in meal or "eggs" in meal) and not ("bacon" in meal and "sausage" in meal)]
```



## *Tuples*
https://docs.python.org/3/library/stdtypes.html#tuples
https://docs.python.org/3/tutorial/datastructures.html#tuples-and-sequences

Tuples are `immutable sequences`, typically used to store collections of heterogeneous data (such as the 2-tuples produced by the enumerate() built-in).  Tuples may be constructed in a number of ways:

* Using a pair of parentheses to denote the empty tuple: `()`
* Using a trailing comma for a singleton tuple: `a,` or `(a,)`
* Separating items with commas: `a, b, c` or `(a, b, c)`
* Using the tuple() built-in: `tuple()` or `tuple(iterable)`



## *Ranges*
https://docs.python.org/3/library/stdtypes.html#ranges

The range type represents an immutable sequence of numbers and is commonly used for looping a specific number of times in for loops.

* class `range(stop)`
* class `range(start, stop[, step])`



# Mapping Types

## *Dictionaries*
https://docs.python.org/3/library/stdtypes.html#mapping-types-dict
https://docs.python.org/3/tutorial/datastructures.html#dictionaries

A `mapping` object maps `hashable` values to arbitrary objects. Mappings are mutable objects. There is currently only one standard mapping type, the dictionary. (For other containers see the built-in list, set, and tuple classes, and the collections module.)

Dictionaries can be created by placing a comma-separated list of key: value pairs within braces, for example: `{'jack': 4098, 'sjoerd': 4127}` or `{4098: 'jack', 4127: 'sjoerd'}`, or by the `dict` constructor.




# Set Types
https://docs.python.org/3/library/stdtypes.html#set-types-set-frozenset
https://docs.python.org/3/tutorial/datastructures.html#sets

A set object is an unordered collection of distinct `hashable` objects. Common uses include membership testing, removing duplicates from a sequence, and computing mathematical operations such as intersection, union, difference, and symmetric difference.


## *Set*
The `set` type is **mutable** — the contents can be changed using methods like `add()` and `remove()`. Since it is mutable, it has no hash value and cannot be used as either a dictionary key or as an element of another set.

```python
# both are sets:
farm_animals = {"sheep", "cow", "hen"}
wild_animals = set(["lion", "tiger", "panther"])

# set constructor:
even = set(range(0, 40, 2))

squares_tuple = (4, 6, 9, 16, 25)
squares = set(squares_tuple)
```


## *Frozenset*
The `frozenset` type is **immutable** and `hashable` — its contents cannot be altered after it is created; it can therefore be used as a dictionary key or as an element of another set.





# **Classes**
https://docs.python.org/3/tutorial/classes.html

## **Class and Instance Variables**
https://docs.python.org/3/tutorial/classes.html#class-and-instance-variables

* Instance variables are for data unique to each instance
* Class variables are for attributes and methods shared by all instances of the class

```python
class Dog:

    kind = 'canine'         # class variable shared by all instances

    def __init__(self, name):
        self.name = name    # instance variable unique to each instance

>>> d = Dog('Fido')
>>> e = Dog('Buddy')
>>> d.kind                  # shared by all dogs
'canine'
>>> e.kind                  # shared by all dogs
'canine'
>>> d.name                  # unique to d
'Fido'
>>> e.name                  # unique to e
'Buddy'
```



## **Inheritance**
https://docs.python.org/3/tutorial/classes.html#inheritance

```python
class DerivedClassName(BaseClassName):
    <statement-1>
    .
    .
    .
    <statement-N>
```



## **Multiple Inheritance**

```python
class DerivedClassName(Base1, Base2, Base3):
    <statement-1>
    .
    .
    .
    <statement-N>
```



## **Private Variables**
https://docs.python.org/3/tutorial/classes.html#private-variables

“Private” instance variables that cannot be accessed except from inside an object don’t exist in Python. However, there is a convention that is followed by most Python code: a name prefixed with an underscore (e.g. _spam) should be treated as a non-public part of the API (whether it is a function, a method or a data member).

```python
class Mapping:
    def __init__(self, iterable):
        self.items_list = []
        self.__update(iterable)

    def update(self, iterable):
        for item in iterable:
            self.items_list.append(item)

    __update = update   # private copy of original update() method

class MappingSubclass(Mapping):

    def update(self, keys, values):
        # provides new signature for update()
        # but does not break __init__()
        for item in zip(keys, values):
            self.items_list.append(item)
```


## Getters and Setters

```python
class Player(object):

	def __init__(self, name):
		self.name = name
		self._lives = 3
		self._level = 1
		self._score = 0

	def _get_lives(self):
		return self._lives

	def _set_lives(self, lives):
		if lives >= 0:
			self._lives = lives
		else:
			print("lives cannot be negative")
			self._lives = 0

	def _get_level(self):
		return self._level

	def _set_level(self, level):
		if level > 0:
			delta = level - self._level
			self._score += delta * 1000
			self._level = level
		else:
			print("Level can't be less than 1")

	# Getters and Setters
	lives = property(_get_lives, _set_lives)
	level = property(_get_level, _set_level)

	# Alternative Getter
	@property
	def score(self):
		return self._score

	# Alternative Setter
	@score.setter
	def score(self, score):
		self._score = score

	def __str__(self):
		# return "Name: {0.name}, Lives: {0.lives}, Level: {0.level}, Score {0.score}".format(self)
		return "Name: {0}, Lives: {1}, Level: {2}, Score {3}".format(self.name, self.lives, self._level, self._score)


```


= = = = = 








# Methods

```python
import datetime
import pytz

class Account:
    """ Simple account class with balance """

    # Static Method, similar to that of C++'s and Java's static method
    @staticmethod
    def _current_time():
        utc_time = datetime.date.time.utcnow()
        return pytz.utc.localize(utc_time)

    def __init__(self, name, balance):
        self.name = name
        self.balance = balance
        self.transaction_list = []
        print("Account created for " + self.name)
    
    def deposit(self, amount)
        if amount > 0:
            self.balance += amount
            # ...

    
```




# String Formatting

Python3:
```python
age = 24

print("My age is " + str(age) + " years")
# My age is 24 years

print("There are {0} days in {1}, {2}, {3}, {4}, {5}, {6} and {7}".format(31, "January", "March", "May", "July", "August", "October", "December"))
# There are 31 days in January, March, May, July, August, October and December

for i in range(1, 12):
    print("No. {0:2} squared is {1:<4} and cubed is {2:4}".format(i, i**2, i**3))

print("Pi is approximately {0:12.50f}".format(22/7))
```

Python2:
```python
# Deprecated in Python3
print("My age is %d %s, %d %s" % (age, "years", 6, "months"))

print("Pi is approximately %12.50f" % (22/7))
```


# Pack Geometry Manager
```python
import tkinter

mainWindow = tkinter.Tk()

mainWindow.title("Hello World")
mainWindow.geometry('640x480+8+400')

label = tkinter.Label(mainWindow, text="Hello World")
label.pack(side='top')

leftFrame = tkinter.Frame(mainWindow)
leftFrame.pack(side='left', anchor='n', fill=tkinter.Y, expand=False)

canvas = tkinter.Canvas(leftFrame, relief='raised', borderwidth=1)
canvas.pack(side='left', anchor='n')

rightFrame = tkinter.Frame(mainWindow)
rightFrame.pack(side='right', anchor='n', expand=True)
button1 = tkinter.Button(rightFrame, text="button1")
button2 = tkinter.Button(rightFrame, text="button2")
button3 = tkinter.Button(rightFrame, text="button3")
button1.pack(side='top')
button2.pack(side='top')
button3.pack(side='top')

mainWindow.mainloop()
```



# Grid Geometry Manager

```python
import tkinter

mainWindow = tkinter.Tk()

mainWindow.title("Hello World")
mainWindow.geometry('640x480+8+200')

label = tkinter.Label(mainWindow, text="Hello World")
label.grid(row=0, column=0)

leftFrame = tkinter.Frame(mainWindow)
leftFrame.grid(row=1, column=1)

canvas = tkinter.Canvas(leftFrame, relief='raised', borderwidth=1)
canvas.grid(row=1, column=0)

rightFrame = tkinter.Frame(mainWindow)
rightFrame.grid(row=1, column=2, sticky='n')
button1 = tkinter.Button(rightFrame, text="button1")
button2 = tkinter.Button(rightFrame, text="button2")
button3 = tkinter.Button(rightFrame, text="button3")
button1.grid(row=0, column=0)
button2.grid(row=1, column=0)
button3.grid(row=2, column=0)


# configure the columns
mainWindow.columnconfigure(0, weight=1)
mainWindow.columnconfigure(1, weight=1)
mainWindow.grid_columnconfigure(2, weight=1)

leftFrame.config(relief='sunken', borderwidth=1)
rightFrame.config(relief='sunken', borderwidth=1)
leftFrame.grid(sticky='ns')
rightFrame.grid(sticky='new')

rightFrame.columnconfigure(0, weight=1)
button2.grid(sticky='ew')

mainWindow.mainloop()
```



# Advanced GUI
```python
import tkinter
import os

mainWindow = tkinter.Tk()

mainWindow.title("Grid Demo")
mainWindow.geometry('640x480+8+200')
mainWindow['padx'] = 8

label = tkinter.Label(mainWindow, text="Hello World")
label.grid(row=0, column=0, columnspan=3)


# Grid
mainWindow.columnconfigure(0, weight=100)
mainWindow.columnconfigure(1, weight=1)
mainWindow.columnconfigure(2, weight=1000)
mainWindow.columnconfigure(3, weight=600)
mainWindow.columnconfigure(4, weight=1000)

mainWindow.rowconfigure(0, weight=1)
mainWindow.rowconfigure(1, weight=10)
mainWindow.rowconfigure(2, weight=1)
mainWindow.rowconfigure(3, weight=3)
mainWindow.rowconfigure(4, weight=3)


# FileList
fileList = tkinter.Listbox(mainWindow)
fileList.grid(row=1, column=0, sticky='nsew', rowspan=2)
fileList.config(border=2, relief='sunken')

for zone in os.listdir('/usr/bin'): # '/Windows/System32'
	fileList.insert(tkinter.END, zone)



# Scrollbar
listScroll = tkinter.Scrollbar(mainWindow, orient=tkinter.VERTICAL, command=fileList.yview)
listScroll.grid(row=1, column=1, sticky='nsw', rowspan=2)
fileList['yscrollcommand'] = listScroll.set



# Frame for the radio buttons
optionFrame = tkinter.LabelFrame(mainWindow, text="File Details")
optionFrame.grid(row=1, column=2, sticky='ne')

rbValue = tkinter.IntVar()
rbValue.set(1)



# Radio buttons
radio1 = tkinter.Radiobutton(optionFrame, text="Filename", value=1, variable=rbValue)
radio2 = tkinter.Radiobutton(optionFrame, text="Path", value=2, variable=rbValue)
radio3 = tkinter.Radiobutton(optionFrame, text="Timestamp", value=3, variable=rbValue)
radio1.grid(row=0, column=0, sticky='w')
radio2.grid(row=1, column=0, sticky='w')
radio3.grid(row=2, column=0, sticky='w')



# Widget to display the result
resultLabel = tkinter.Label(mainWindow, text="Result")
resultLabel.grid(row=2, column=2, sticky='nw')
result = tkinter.Entry(mainWindow)
result.grid(row=2, column=2, sticky='sw')



# Frame for the time spinners
timeFrame = tkinter.LabelFrame(mainWindow, text="Time")
timeFrame.grid(row=3, column=0, sticky='new')



# Time spinners
hourSpinner = tkinter.Spinbox(timeFrame, width=2, values=tuple(range(0,24)))
minuteSpinner = tkinter.Spinbox(timeFrame, width=2, from_=0, to=59)
secondSpinner = tkinter.Spinbox(timeFrame, width=2, from_=0, to=59)

hourSpinner.grid(row=0, column=0)
tkinter.Label(timeFrame, text=':').grid(row=0, column=1)
minuteSpinner.grid(row=0, column=2)
tkinter.Label(timeFrame, text=':').grid(row=0, column=3)
secondSpinner.grid(row=0, column=4)
timeFrame['padx'] = 36


# Frame for the date spinners
dateFrame = tkinter.Frame(mainWindow)
dateFrame.grid(row=4, column=0, sticky='new')


# Date Labels
dayLabel = tkinter.Label(dateFrame, text="Day")
monthLabel = tkinter.Label(dateFrame, text="Month")
yearLabel = tkinter.Label(dateFrame, text="Year")

dayLabel.grid(row=0, column=0, sticky='w')
monthLabel.grid(row=0, column=1, sticky='w')
yearLabel.grid(row=0, column=2, sticky='w')


# Date Spinners
daySpin = tkinter.Spinbox(dateFrame, width=5, from_=1, to=31)
monthSpin = tkinter.Spinbox(dateFrame, width=5, values=("Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"))
yearSpin = tkinter.Spinbox(dateFrame, width=5, from_=2000, to=2099)
daySpin.grid(row=1, column=0)
monthSpin.grid(row=1, column=1)
yearSpin.grid(row=1, column=2)



# Buttons
okButton = tkinter.Button(mainWindow, text="OK")
cancelButton = tkinter.Button(mainWindow, text="Cancel", command=mainWindow.destroy)
okButton.grid(row=4, column=3, sticky='e')
cancelButton.grid(row=4, column=4, sticky='w')


mainWindow.mainloop()
```



# Functions

```python
def python_food():
print("spam and eggs")
```




# Blackjack Code
```python
import random

try:
	import tkinter
except ImportError:  # python 2
	import Tkinter as tkinter


def load_images(card_images):
	suits = ['heart', 'club', 'diamond', 'spade']
	face_cards = ['jack', 'queen', 'king']

	if tkinter.TkVersion >= 8.6:
		extension = 'png'
	else:
		extension = 'ppm'

	# for each suit, retrieve the image for the cards
	for suit in suits:
		# first the number cards 1 to 10
		for card in range(1, 11):
			name = 'cards/{}_{}.{}'.format(str(card), suit, extension)
			image = tkinter.PhotoImage(file=name)
			card_images.append((card, image,))

		# next the face cards
		for card in face_cards:
			name = 'cards/{}_{}.{}'.format(str(card), suit, extension)
			image = tkinter.PhotoImage(file=name)
			card_images.append((10, image,))


def deal_card(frame):
	# pop the next card off the top of the deck
	next_card = deck.pop(0)
	# and add it to back of the pack
	deck.append(next_card)
	# add the image to a Label and display the label
	tkinter.Label(frame, image=next_card[1], relief='raised').pack(side='left')
	# now return the card's face value
	return next_card


def score_hand(hand):
	# Calculate the total score of all cards in the list.
	# Only one ace can have the value 11, and this will be reduce to 1 if the hand would bust.
	score = 0
	ace = False
	for next_card in hand:
		card_value = next_card[0]
		if card_value == 1 and not ace:
			ace = True
			card_value = 11
		score += card_value
		# if we would bust, check if there is an ace and subtract 10
		if score > 21 and ace:
			score -= 10
			ace = False
	return score


def deal_dealer():
	dealer_score = score_hand(dealer_hand)
	while 0 < dealer_score < 17:
		dealer_hand.append(deal_card(dealer_card_frame))
		dealer_score = score_hand(dealer_hand)
		dealer_score_label.set(dealer_score)

	player_score = score_hand(player_hand)
	if player_score > 21:
		result_text.set("Dealer wins!")
	elif dealer_score > 21 or dealer_score < player_score:
		result_text.set("Player wins!")
	elif dealer_score > player_score:
		result_text.set("Dealer wins!")
	else:
		result_text.set("Draw!")


def deal_player():
	player_hand.append(deal_card(player_card_frame))
	player_score = score_hand(player_hand)

	player_score_label.set(player_score)
	if player_score > 21:
		result_text.set("Dealer Wins!")


def initial_deal():
	deal_player()
	dealer_hand.append(deal_card(dealer_card_frame))
	dealer_score_label.set(score_hand(dealer_hand))
	deal_player()


def new_game():
	global dealer_card_frame
	global player_card_frame
	global dealer_hand
	global player_hand
	# embedded frame to hold the card images
	dealer_card_frame.destroy()
	dealer_card_frame = tkinter.Frame(card_frame, background='green')
	dealer_card_frame.grid(row=0, column=1, sticky='ew', rowspan=2)
	# embedded frame to hold the card images
	player_card_frame = tkinter.Frame(card_frame, background="green")
	player_card_frame.grid(row=2, column=1, sticky='ew', rowspan=2)

	result_text.set("")

	# Create the list to store the dealer's and player's hands
	dealer_hand = []
	player_hand = []
	initial_deal()


def shuffle():
	random.shuffle(deck)


def play():
	initial_deal()
	mainWindow.mainloop()


mainWindow = tkinter.Tk()

# Set up the screen and frames for the dealer and player
mainWindow.title("Black Jack")
mainWindow.geometry("640x480")
mainWindow.configure(background='green')

result_text = tkinter.StringVar()
result = tkinter.Label(mainWindow, textvariable=result_text)
result.grid(row=0, column=0, columnspan=3)

card_frame = tkinter.Frame(mainWindow, relief="sunken", borderwidth=1, background="green")
card_frame.grid(row=1, column=0, sticky='ew', columnspan=3, rowspan=2)

dealer_score_label = tkinter.IntVar()
tkinter.Label(card_frame, text="Dealer", background="green", fg='white').grid(row=0, column=0)
tkinter.Label(card_frame, textvariable=dealer_score_label, background="green", fg="white").grid(row=1, column=0)
# embedded frame to hold the card images
dealer_card_frame = tkinter.Frame(card_frame, background="green")
dealer_card_frame.grid(row=0, column=1, sticky="ew", rowspan=2)

player_score_label = tkinter.IntVar()

tkinter.Label(card_frame, text="Player", background="green", fg="white").grid(row=2, column=0)
tkinter.Label(card_frame, textvariable=player_score_label, background="green", fg="white").grid(row=3, column=0)
# embedded frame to hold the card images
player_card_frame = tkinter.Frame(card_frame, background="green")
player_card_frame.grid(row=2, column=1, sticky='ew', rowspan=2)

button_frame = tkinter.Frame(mainWindow)
button_frame.grid(row=3, column=0, columnspan=3, sticky='w')

dealer_button = tkinter.Button(button_frame, text="Dealer", command=deal_dealer)
dealer_button.grid(row=0, column=0)

player_button = tkinter.Button(button_frame, text="Player", command=deal_player)
player_button.grid(row=0, column=1)

new_game_button = tkinter.Button(button_frame, text="New Game", command=new_game)
new_game_button.grid(row=0, column=2)

shuffle_button = tkinter.Button(button_frame, text="Shuffle", command=shuffle)
shuffle_button.grid(row=0, column=3)

# load cards
cards = []
load_images(cards)
print(cards)
# Create a new deck of cards and shuffle them
deck = list(cards) + list(cards) + list(cards)
shuffle()

# Create the list to store the dealer's and player's hands
dealer_hand = []
player_hand = []

if __name__ == "__main__":
	play()


```