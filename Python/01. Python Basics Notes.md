# **Python Basic Notes**

# *Table of Contents*
0. [Best Practices](#best-practices)
1. [Lists](#lists)
2. [List Comprehensions](#list-comprehensions)
3. [Sets](#sets)
4. [Tuples](#tuples)
5. [Dictionaries](#dictionaries)
6. [Ranges](#ranges)
7. [Input and Output](#input-and-output)




1. [Functions](#functions)



	2. [Keyword Arguments](#keyword-arguments)
	3. [Arbitary Argument Lists](#arbitary-argument-lists)
	4. [Lambda Expressions](#lambda-expressions)
	5. [Function Annotations](#function-annotations)
2. [Data Structures](#data-structures)
	
3. [Modules](#modules)
	1. [Executing modules as scripts](#modules-as-scripts)
4. [Input and Output](#input-and-output)
	1. [Fancier Output Formatting](#fancier-output-formatting)]
	2. [Formatted String Literals](#formatted-string-literals)
	3. [Reading and Writing Files](#reading-and-writing-files)
	4. [Saving data with JSON](#saving-data-with-json)






# Best Practices

## *Executing modules as scripts*

https://docs.python.org/3/tutorial/modules.html#executing-modules-as-scripts

```python
python fibo.py <arguments>
```

Add `__name__ == "__main__"` to the end of the module.

```python
if __name__ == "__main__":
    import sys
    fib(int(sys.argv[1]))
```








# Lists

https://docs.python.org/3/library/stdtypes.html#lists
https://docs.python.org/3/tutorial/datastructures.html#more-on-lists

Lists are `mutable sequences`. Lists may be constructed in several ways:
* Using a pair of square brackets to denote the empty list: `[]`
* Using square brackets, separating items with commas: `[a]`, `[a, b, c]`
* Using a list comprehension: `[x for x in iterable]`
* Using the type constructor: `list()` or `list(iterable)`

```python
even = [2, 4, 6, 8]
odd = [1, 3, 5, 7]

numbers = even + odd

numbers_in_order = sorted(numbers)      # does not mutate, returns new list
numbers.sort()                          # mutates the object
```


### *Using Lists as Stacks*
```python
>>> stack = [3, 4, 5]
>>> stack.append(6)
>>> stack
[3, 4, 5, 6]
>>> stack.pop()
6
>>> stack
[3, 4, 5]
```


### *Using Lists as Queues*
To implement a queue, use `collections.deque` which was designed to have fast appends and pops from both ends. For example:

```python
>>> from collections import deque
>>> queue = deque(["Eric", "John", "Michael"])
>>> queue.append("Terry")           # Terry arrives
>>> queue.popleft()                 # The first to arrive now leaves
'Eric'
>>> queue.popleft()                 # The second to arrive now leaves
'John'
>>> queue                           # Remaining queue in order of arrival
deque(['Michael', 'Terry'])
```



# List Comprehensions

https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions

[*`expr`* for *`val`* in *`collection`*]

[*`expr`* for *`val`* in *`collection`* if *`<test1>`* and *`<test2>`*]

[*`expr`* for *`val1`* in *`collection1`* and *`val2`* in *`collection2`*]

Example 1:

```python
squares = [number ** 2 for number in range(1,7)]
print(squares)


def centre_text(*args):
	text = "-".join([str(arg) for arg in args])
	left_marge = (80 - len(text)) // 2
	print(" " * left_margin, text)

centre_text("first", "second", 3, 4, "spam")
# you can't use join() on an int.
# with List Comprehension, you can quickly convert it into a str



fussy_meals = [meal for meal in menu if
	("spam" in meal or "eggs" in meal) and not ("bacon" in meal and "sausage" in meal)]
```

Example 2:

```python
squares = list(map(lambda x: x**2, range(10)))
# or, equivalently:
squares = [x**2 for x in range(10)]
```

Example 3:

```python
>>> [(x, y) for x in [1,2,3] for y in [3,1,4] if x != y]
[(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]

# equivalent to:
>>> combs = []
>>> for x in [1,2,3]:
...     for y in [3,1,4]:
...         if x != y:
...             combs.append((x, y))
...
>>> combs
[(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]

```

## *Nested List Comprehensions*

https://docs.python.org/3/tutorial/datastructures.html#nested-list-comprehensions

The following list comprehension will `transpose` rows and columns:

```python
>>> matrix = [
...     [1, 2, 3, 4],
...     [5, 6, 7, 8],
...     [9, 10, 11, 12],
... ]

>>> [[row[i] for row in matrix] for i in range(4)]
[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]
```

In the real world, you should prefer built-in functions to complex flow statements. The `zip()` function would do a great job for this use case:

```python
>>> list(zip(*matrix))
[(1, 5, 9), (2, 6, 10), (3, 7, 11), (4, 8, 12)]
```



# Sets
https://docs.python.org/3/library/stdtypes.html#set-types-set-frozenset
https://docs.python.org/3/tutorial/datastructures.html#sets

The set type is `mutable` — the contents can be changed using methods like `add()` and `remove()`. Since it is mutable, it has no hash value and cannot be used as either a dictionary key or as an element of another set.

```python
# both are sets:
farm_animals = {"sheep", "cow", "hen"}
wild_animals = set(["lion", "tiger", "panther"])

# set constructor:
even = set(range(0, 40, 2))

squares_tuple = (4, 6, 9, 16, 25)
squares = set(squares_tuple)
```

```python
>>> basket = {'apple', 'orange', 'apple', 'pear', 'orange', 'banana'}
>>> print(basket)                      # show that duplicates have been removed
{'orange', 'banana', 'pear', 'apple'}
>>> 'orange' in basket                 # fast membership testing
True
>>> 'crabgrass' in basket
False

>>> # Demonstrate set operations on unique letters from two words
...
>>> a = set('abracadabra')
>>> b = set('alacazam')
>>> a                                  # unique letters in a
{'a', 'r', 'b', 'c', 'd'}
>>> a - b                              # letters in a but not in b
{'r', 'd', 'b'}
>>> a | b                              # letters in a or b or both
{'a', 'c', 'r', 'd', 'b', 'm', 'z', 'l'}
>>> a & b                              # letters in both a and b
{'a', 'c'}
>>> a ^ b                              # letters in a or b but not both
{'r', 'd', 'b', 'm', 'z', 'l'}
```



## Set Comprehensions:
```python
>>> a = {x for x in 'abracadabra' if x not in 'abc'}
>>> a
{'r', 'd'}
```

## *Frozenset*
The `frozenset` type is **immutable** and `hashable` — its contents cannot be altered after it is created; it can therefore be used as a dictionary key or as an element of another set.


# Tuples
https://docs.python.org/3/library/stdtypes.html#tuples
https://docs.python.org/3/tutorial/datastructures.html#tuples-and-sequences

Tuples are `immutable sequences`.  Tuples may be constructed in a number of ways:

* Using a pair of parentheses to denote the empty tuple: `()`
* Using a trailing comma for a singleton tuple: `a,` or `(a,)`
* Separating items with commas: `a, b, c` or `(a, b, c)`
* Using the tuple() built-in: `tuple()` or `tuple(iterable)`


```python
>>> t = 12345, 54321, 'hello!'

>>> t
(12345, 54321, 'hello!')

>>> # Tuples may be nested:
... u = t, (1, 2, 3, 4, 5)
>>> u
((12345, 54321, 'hello!'), (1, 2, 3, 4, 5))

>>> # Tuples are immutable:
... t[0] = 88888
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: 'tuple' object does not support item assignment

>>> # but they can contain mutable objects:
... v = ([1, 2, 3], [3, 2, 1])
>>> v
([1, 2, 3], [3, 2, 1])
```






# Dictionaries
https://docs.python.org/3/library/stdtypes.html#mapping-types-dict
https://docs.python.org/3/tutorial/datastructures.html#dictionaries

A `mapping` object maps `hashable` values to arbitrary objects. Mappings are `mutable objects`. 

Dictionaries can be created by placing a comma-separated list of key: value pairs within braces, for example: `{'jack': 4098, 'sjoerd': 4127}` or `{4098: 'jack', 4127: 'sjoerd'}`, or by the `dict` constructor.


```python
>>> tel = {'jack': 4098, 'sape': 4139}
>>> tel['guido'] = 4127

>>> tel
{'jack': 4098, 'sape': 4139, 'guido': 4127}


>>> del tel['sape']

>>> tel['irv'] = 4127
>>> tel
{'jack': 4098, 'guido': 4127, 'irv': 4127}

>>> list(tel)
['jack', 'guido', 'irv']

>>> sorted(tel)
['guido', 'irv', 'jack']

>>> 'guido' in tel
True
>>> 'jack' not in tel
False
```

## Dict Constructor:
```python
>>> dict([('sape', 4139), ('guido', 4127), ('jack', 4098)])
{'sape': 4139, 'guido': 4127, 'jack': 4098}
```

## Dict Comprehensions:
```python
>>> {x: x**2 for x in (2, 4, 6)}
{2: 4, 4: 16, 6: 36}
```





## *Ranges*
https://docs.python.org/3/library/stdtypes.html#ranges

The range type represents an `immutable sequence of numbers` and is commonly used for looping a specific number of times in for loops.

* class `range(stop)`
* class `range(start, stop[, step])`
























# Input and Output


## Fancier Output Formatting
https://docs.python.org/3/tutorial/inputoutput.html#fancier-output-formatting

To use `formatted string literals`, begin a string with f or F before the opening quotation mark or triple quotation mark. Inside this string, you can write a Python expression between { and } characters that can refer to variables or literal values.

```python
>>> year = 2016
>>> event = 'Referendum'
>>> f'Results of the {year} {event}'
'Results of the 2016 Referendum'
```


The `str.format()` method of strings requires more manual effort. You’ll still use { and } to mark where a variable will be substituted and can provide detailed formatting directives, but you’ll also need to provide the information to be formatted.

```python
>>> yes_votes = 42_572_654
>>> no_votes = 43_132_495
>>> percentage = yes_votes / (yes_votes + no_votes)
>>> '{:-9} YES votes  {:2.2%}'.format(yes_votes, percentage)
' 42572654 YES votes  49.67%'
```



## Formatted String Literals
https://docs.python.org/3/tutorial/inputoutput.html#formatted-string-literals


`Formatted string literals` (also called f-strings for short) let you include the value of Python expressions inside a string by prefixing the string with f or F and writing expressions as `{expression}`.

```python
>>> import math
>>> print(f'The value of pi is approximately {math.pi:.3f}.')
The value of pi is approximately 3.142.
```


Passing an integer after the `':'` will cause that field to be a minimum number of characters wide. This is useful for making columns line up.

```python
>>> table = {'Sjoerd': 4127, 'Jack': 4098, 'Dcab': 7678}
>>> for name, phone in table.items():
...     print(f'{name:10} ==> {phone:10d}')
...
Sjoerd     ==>       4127
Jack       ==>       4098
Dcab       ==>       7678
```



Other modifiers can be used to convert the value before it is formatted. `'!a'` applies `ascii()`, `'!s'` applies `str()`, and `'!r'` applies `repr()`:

```python
>>> animals = 'eels'
>>> print(f'My hovercraft is full of {animals}.')
My hovercraft is full of eels.
>>> print(f'My hovercraft is full of {animals!r}.')
My hovercraft is full of 'eels'.
```



## Reading and Writing Files

`open()` returns a `file object`, and is most commonly used with two arguments: `open(filename, mode)`.

```python
f = open('workfile', 'w')
#
#
f.close()
```

* The first argument is a string containing the filename. 
* The second argument is another string containing a few characters describing the way in which the file will be used. mode can be 
	* 'r' when the file will only be read, 
	* 'w' for only writing (an existing file with the same name will be erased), and 
	* 'a' opens the file for appending; any data written to the file is automatically added to the end. 
	* 'r+' opens the file for both reading and writing.


```python
with open('workfile') as f:
	read_data = f.read()
```


* `readline()` reads a single line from the file; a newline character (`\n`) is left at the end of the string, and is only omitted on the last line of the file if the files doesn't end in a new line.
* For reading lings from a file, you can loop over the file object. This is memory efficient, fast, and leads to simple code:

```python
for line in f:
	print(line, end='')

This is the first line of the file.
Second line of the file
```



## Saving data with JSON

https://docs.python.org/3/tutorial/inputoutput.html#saving-structured-data-with-json

The standard module called `json` can take Python data hierarchies, and convert them to string representations; this process is called `serializing`. Reconstructing the data from the string representation is called `deserializing`.

If you have an object x, you can view its JSON string representation with a simple line of code:

```python
>>> import json
>>> json.dumps([1, 'simple', 'list'])
'[1, "simple", "list"]'
```

Another variant of the `dumps()` function, called `dump()`, simply serializes the object to a `text file`. So if `f` is a `text file` object opened for writing, we can do this:

```python
json.dump(x, f)
```

To decode the object again, if `f` is a `text file` object which has been opened for reading:

```python
x = json.load(f)
```














































# Functions

For more info:
* [Keyword arguments](https://docs.python.org/3/tutorial/controlflow.html#keyword-arguments)
* [Docstrings](https://www.python.org/dev/peps/pep-0257/)
* [Function annotations](https://docs.python.org/3/tutorial/controlflow.html#function-annotations)


```python
class Artist(Musician):		# Inheritance
	"""Basic class to store artist details.

	Attributes:
		name (str): The name of the artist.
		albums (List[Album]): A list of the albums by this artist.
			The list includes only those albums in this collection, it is
			not an exhaustive list of the artist's published albums.
	
	Methods:
		add_album: Use to add a new album to the artist's albums list
	""" 	# Docstring

	def __init__(self, name):
		super().__init__(dob="01/01/1990", nickname="dog")	# Inheritance
		self.name = name
		self.albums = []

	def add_song(self, name: str = self.name, year: str, title: str) -> None:		# Function Annotations
		"""Add a new song to the collection of albums

		This method will add the song to an album in the collection.
		A new album will be created in the collection if it doesn't already exist.

		Args:
			name (str): The name of the album
			year (int): The year the album was produced
			title (str): The title of the song
		"""

		# code
```




## *Keyword Arguments*

https://docs.python.org/3/tutorial/controlflow.html#keyword-arguments

Functions can also be called using keyword arguments of the form kwarg=value. For instance, the following function:

```python
def parrot(voltage, state='a stiff', action='voom', type='Norwegian Blue'):
    print("-- This parrot wouldn't", action, end=' ')
    print("if you put", voltage, "volts through it.")
    print("-- Lovely plumage, the", type)
    print("-- It's", state, "!")

parrot(1000)                                          # 1 positional argument
parrot(voltage=1000)                                  # 1 keyword argument
parrot(voltage=1000000, action='VOOOOOM')             # 2 keyword arguments
parrot(action='VOOOOOM', voltage=1000000)             # 2 keyword arguments
parrot('a million', 'bereft of life', 'jump')         # 3 positional arguments
parrot('a thousand', state='pushing up the daisies')  # 1 positional, 1 keyword
```



### Using Splat:

```python
def cheeseshop(kind, *arguments, **keywords):
    print("-- Do you have any", kind, "?")
    print("-- I'm sorry, we're all out of", kind)
    for arg in arguments:
        print(arg)
    print("-" * 40)
    for kw in keywords:
        print(kw, ":", keywords[kw])
```



## *Arbitary Argument Lists*

https://docs.python.org/3/tutorial/controlflow.html#arbitrary-argument-lists

Finally, the least frequently used option is to specify that a function can be called with an arbitrary number of arguments. These arguments will be wrapped up in a tuple (see Tuples and Sequences). Before the variable number of arguments, zero or more normal arguments may occur.

```python
def write_multiple_items(file, separator, *args):
    file.write(separator.join(args))

>>> def concat(*args, sep="/"):
...     return sep.join(args)
...
>>> concat("earth", "mars", "venus")
'earth/mars/venus'
>>> concat("earth", "mars", "venus", sep=".")
'earth.mars.venus'
```



## *Lambda Expressions*

https://docs.python.org/3/tutorial/controlflow.html#lambda-expressions

Small anonymous functions can be created with the lambda keyword. This function returns the sum of its two arguments: lambda a, b: a+b. Lambda functions can be used wherever function objects are required. They are syntactically restricted to a single expression. Semantically, they are just syntactic sugar for a normal function definition. Like nested function definitions, lambda functions can reference variables from the containing scope:

```python
>>> def make_incrementor(n):
...     return lambda x: x + n
...
>>> f = make_incrementor(42)
>>> f(0)
42
>>> f(1)
43
```



## *Function Annotations*

https://docs.python.org/3/tutorial/controlflow.html#function-annotations

Annotations are stored in the `__annotations__` attribute of the function as a dictionary and have no effect on any other part of the function. Parameter annotations are defined by a colon after the parameter name, followed by an expression evaluating to the value of the annotation. Return annotations are defined by a literal ->, followed by an expression, between the parameter list and the colon denoting the end of the def statement. The following example has a positional argument, a keyword argument, and the return value annotated:

```python
>>> def f(ham: str, eggs: str = 'eggs') -> str:
...     print("Annotations:", f.__annotations__)
...     print("Arguments:", ham, eggs)
...     return ham + ' and ' + eggs
...
>>> f('spam')
Annotations: {'ham': <class 'str'>, 'return': <class 'str'>, 'eggs': <class 'str'>}
Arguments: spam eggs
'spam and eggs'
```



































= = = =


3. [Classes](#classes)
    1. [Class and Instance Variables](#class-and-instance-variables)
    2. [Inheritance](#inheritance)
    3. [Private Variables](#private-variables)
	4. [Getters and Setters](#getters-and-setters)
9. [Methods](#methods)
9. [String Formatting](#string-formatting)
9. [TkInter]
    1. [Pack Geometry Manager](#pack-geometry-manager)
    2. [Grid Geometry Manager](#grid-geomtry-manager)
    3. [Advanced GUI](#advanced-gui)
9. [Blackjack Code](#blackjack-code)





# **Basics**

## *Falsey Values*
* False
* None
* 0
* 0.0
* [] *(empty list)*
* () *(empty tuple)*
* '' *(empty string)*
* "" *(empty string)*
* {} *(empty mapping)*


## *Iterators*
https://docs.python.org/3/library/stdtypes.html#iterator-types

When using a for loop, Python is generating an `iterator object` under the hood.

```python
alphabet = "abcdefg"

my_iterator = iter(alphabet)
print(my_iterator)
print(next(my_iterator))
print(next(my_iterator))
print(next(my_iterator))

# output:
# <str_iterator object at 0x1027cf450>
# a
# b
# c


for char in alphabet:
    print(char)

# is the same as:
for char in iter(alphabet):
    print(char)
```



## *Generators*
https://docs.python.org/3/tutorial/classes.html#generators

`Generator`s are a simple and powerful tool for creating iterators. They are written like regular functions but use the `yield` statement whenever they want to return data. Each time `next()` is called on it, the generator resumes where it left off (it remembers all the data values and which statement was last executed). An example shows that generators can be trivially easy to create:

```python
def reverse(data):
    for index in range(len(data)-1, -1, -1):
        yield data[index]


# >>> for char in reverse('golf'):
# ...     print(char)
# ...
# f
# l
# o
# g
```

### Example:
Calculating Pi:

```python
def oddnumbers():
    n = 1
    while True:
        yield n
        n += 2

def pi_series():
    odds = oddnumbers()
    approximation = 0
    while True:
        approximation += (4 / next(odds))
        yield approximation
        approximation -= (4 / next(odds))
        yield approximation

approx_pi = pi_series()

for x in range(10000000):
    print(next(approx_pi))
```

Searching the Filesystem:
```python
import os
import fnmatch

def find_albums(root, artist_name):
    for path, directories, files in os.walk(root):
        for artist in fnmatch.filter(directories, artist_name):
        subdir = os.path.join(path, artist)
        for album_path, albums, _ in os.walk(subdir):
            for album in albums:
                yield os.path.join(album_path, album), album

def find_songs(albums):
    for album in albums:
        for song in os.listdir(album[0]):   # we want the path, not the name of the album
            yield song

album_list = find_albums("music", "black*")
song_list = find_songs(album_list)

for s in song_list:
    print(s)
```



# **Data Structures**
https://docs.python.org/3/tutorial/datastructures.html

# Sequence Types

## *Lists*
https://docs.python.org/3/library/stdtypes.html#lists
https://docs.python.org/3/tutorial/datastructures.html#more-on-lists

Lists are `mutable sequences`, typically used to store collections of homogeneous items (where the precise degree of similarity will vary by application).  Lists may be constructed in several ways:
* Using a pair of square brackets to denote the empty list: `[]`
* Using square brackets, separating items with commas: `[a]`, `[a, b, c]`
* Using a list comprehension: `[x for x in iterable]`
* Using the type constructor: `list() `or `list(iterable)`

```python
even = [2, 4, 6, 8]
odd = [1, 3, 5, 7]

numbers = even + odd

numbers_in_order = sorted(numbers)      # does not mutate, returns new list
numbers.sort()                          # mutates the object
```







## *Tuples*
https://docs.python.org/3/library/stdtypes.html#tuples
https://docs.python.org/3/tutorial/datastructures.html#tuples-and-sequences

Tuples are `immutable sequences`, typically used to store collections of heterogeneous data (such as the 2-tuples produced by the enumerate() built-in).  Tuples may be constructed in a number of ways:

* Using a pair of parentheses to denote the empty tuple: `()`
* Using a trailing comma for a singleton tuple: `a,` or `(a,)`
* Separating items with commas: `a, b, c` or `(a, b, c)`
* Using the tuple() built-in: `tuple()` or `tuple(iterable)`







# Mapping Types













= = = = = 








# Methods

```python
import datetime
import pytz

class Account:
    """ Simple account class with balance """

    # Static Method, similar to that of C++'s and Java's static method
    @staticmethod
    def _current_time():
        utc_time = datetime.date.time.utcnow()
        return pytz.utc.localize(utc_time)

    def __init__(self, name, balance):
        self.name = name
        self.balance = balance
        self.transaction_list = []
        print("Account created for " + self.name)
    
    def deposit(self, amount)
        if amount > 0:
            self.balance += amount
            # ...

    
```




# String Formatting

Python3:
```python
age = 24

print("My age is " + str(age) + " years")
# My age is 24 years

print("There are {0} days in {1}, {2}, {3}, {4}, {5}, {6} and {7}".format(31, "January", "March", "May", "July", "August", "October", "December"))
# There are 31 days in January, March, May, July, August, October and December

for i in range(1, 12):
    print("No. {0:2} squared is {1:<4} and cubed is {2:4}".format(i, i**2, i**3))

print("Pi is approximately {0:12.50f}".format(22/7))
```

Python2:
```python
# Deprecated in Python3
print("My age is %d %s, %d %s" % (age, "years", 6, "months"))

print("Pi is approximately %12.50f" % (22/7))
```




