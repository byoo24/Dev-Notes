# *Table of Contents*
1. [Rails getting started](#started)
    1. [Helpful Gems](#gems)
2. [Migrations](#migrations)
3. [Models and ActiveRecord](#models)



<!-- 2. [Controllers](#controllers)
3. [Routes](#routes)
4. [Databases](#databases)

7. [Named Scopes](#named-scopes)
8. [Associations](#associations)
9. [CRUD, REST, and Resourceful Routes](#crud)
10. [Assets](#assets)
11. [Forms](#forms)
12. [Data Validation](#data-validation) -->


- - -


<a name="started"></a>
# **Rails Getting Started**

```ruby
# Create rails project:
# =====================
rails new demo_project -G --database=postgresql
```
By default, rails will initialize your new project as a git repository. Adding the -G flag will instruct rails to create a project without the new repository.


```ruby
# Create rails project:
# =====================
rails new demo_project -G --database=postgresql


# Login to mysql
# =====================
mysql -u root -p


# Create Databases
# =====================
CREATE DATABASE project_name_development;
CREATE DATABASE project_name_test;


# Connect to Database with a user and not root
# =====================
GRANT ALL PRIVILEGES ON project_name_development.* TO 'user_name'@'localhost' IDENTIFIED BY 'user_password'
GRANT ALL PRIVILEGES ON project_name_test.* TO 'user_name'@'localhost' IDENTIFIED BY 'user_password'


# Configure config/database.yml
# =====================
default: &default
  .
  .
  username: user_name
  password: user_password
end


# in terminal:
# checks to see if the configuration was successful
# =====================
rails db:schema:dump
```

<a name="gems"></a>
# Helpful Gems

```ruby
group :development do
  # Run 'bundle exec annotate' in Terminal to add helpful comments to models.
  gem 'annotate'

  # These two give you a great error handling page.
  # But make sure to never use them in production!
  gem 'better_errors'
  gem 'binding_of_caller'

  # Gotta have byebug...
  gem 'byebug'

  # pry > irb
  gem 'pry-rails'
end
```



- - -



<a name="migrations"></a>
# **Migrations**
* Adds tables to the database (written in Ruby)
* "Migrate" your database from one state to another
* Contains instructions for both:
  + Moving "up" to a new State
  + Moving back "down" to the previous state

```ruby
rails generate migration MigrationName
```

# *Generate Model*
* Automatically creates file in `db/migrate`
* Automatically creates file in app/models
* Automatically creates file in test directory

```ruby
rails generate model ModelName
rails g model Post title:string content:text category_id:integer
```

### *Run a Migration*
```ruby
rails db:migrate
rails db:migrate VERSION=0
rails db:migrate VERSION=20161231235959
rails db:migrate:status
rails db:up VERSION=20161231235959
rails db:down VERSION=20161231235959
rails db:redo VERSION=20161231235959
```

### *Table Column Types and Options*

```ruby
# Table Column Types
# ======================
binary, boolean, date, datetime, decimal, float, integer, string, text, time


# Table Column Options
# ======================
:limit => size
:default => value
:null => true/false
:precision => number
:scale => number


# Example:
class CreateUsers < ActiveRecord::Migration[5.0]

  def up
    create_table :users do |t|
      t.column "first_name", :string, :limit => 25      # long version
      t.string "last_name", :limit => 50                # shorthand
      t.string "email", :default => '', :null => false
      t.string "password", :limit => 40

      t.timestamps
      # t.datetime "created_at"
      # t.datetime "updated_at"
    end
  end

  def down
    drop_table :users
  end

end
```


### *Migration Methods*
```ruby
# Table Migration Methods
# =======================
create_table(table, options) do |t|
  ...columns...
end

drop_table(table_name)
rename_table(table_name, new_table_name)


# Column Migration Methods
# =======================
add_column(table_name, column_name, type, options_hash)
remove_column(table_name, column_name)
rename_column(table_name, column_name, new_column_name)
change_column(table_name, column_name, type, options_hash)


# Index Migration Methods
# =======================
add_index(table_name, [column1, column2], options_hash)
remove_index(table_name, column_name)


# Index Migration Method Options
# ==============================
:unique => true/false
:name => "your_custom_name"


# Misc
# ======
null: true/false  # adds a NULL/NOT NULL constraint
default: value   # specify a default value


# Example:
# ==============================
class AlterUsers < ActiveRecord::Migration[5.0]

  def change
    rename_table("users", "admin_users")
    add_column("admin_users", "username", :string, :limit => 25, :after => "email")
    change_column("admin_users", "email", :string, :limit => 100)
    rename_column("admin_users", "password", "hashed_password")
    puts "*** Adding an index ***"
    add_intex("admin_users", "username")
  end

end
```



- - -



<a name="models"></a>
# **Models and ActiveRecord**
```ruby
rails generate model ModelName
```

### *ActiveRecord and ActiveRelation*

*What is ActiveRecord?*
* `active record`: design pattern for relational databases
* `ActiveRecord`: Rails implementation of active record pattern
* Retrieve and manipulate data as **objects**, not as static rows

*ActiveRecord Objects: "Intelligent"*
* Understand the structure of the table
* Contain data from table rows
* Know how to create, read, update, and delete rows
* Can be manipulated as objects; then saved easily

```ruby
# Active Record Example:
user = User.new
user.first_name = "Kevin"
user.save     # SQL INSERT

user.last_name = "Skoglund"
user.save   # SQL UPDATE

user.delete   #SQL DELETE
```


*What is ActiveRelation?*
* Also known as "ARel"
* Object-oriented interpretation of relational algebra

*What is ActiveRelation?*
* Simplifies the generation of complex database queries
  * Small queries are chainable (like most Ruby objects).
  * Complex joins and aggregations use efficient SQL.
  * Queries do not execute until needed.


```ruby
users = User.where(:first_name => "Kevin")
users = users.order("last_name ASC").limit(5)

# SELECT users.* FROM users
# WHERE users.first_name = 'Kevin'
# ORDER BY users.last_name ASC
# LIMIT 5
```



### *Rails Console*
```
rails console development
rails console
rails c
```

### *Create, Update, Destroy Records*

* *Create Records*
  + `New/save`
    - Instantiate object
    - Set values
    - Save
  + `Create`
    - Instantiate object, set values, and save
* *Update Records*
  + `Find/save`
    - Find record
    - Set values
    - Save
  + `Find/update_attributes`
    - Find record
    - Set Values and save
* *Delete Records*
  + `Find/destroy`
    - Find record
    - Destroy
    - *(Gotcha moment: There is "Delete" but it does something different.)*


```ruby
rails console development

# New/Save (Separate commands)
# ========================
subject = Subject.new
subject.name = "Subject One"
subject.position = 2
subject.save

  # Create (New and Save in one command)
  # ========================
  subject = Subject.create(:name => "Subject Two", :position => 2)



# Update/Save (Separate commands)
# ========================
subject = Subject.find(1)
subject.name = "Initial Subject"
subject.save

  # Find/update_attributes (Find and Save in one command)
  # ========================
  subject = Subject.find(2)
  subject.update_attributes(:name => "Next Subject", :visible => true)



# Find/Destroy
# ========================
subject = Subject.find(3)
subject.destroy
```

### *Find Records*

| Name | Command | Return Value |
| ---  | --- | --- |
| `Primary Key Finder` | Subject.find( *key* ) | Object or an error |
| `Dynamic Finders` | Subject.find_by_id( *key* ) | Object or nil |
| -                 | Subject.find_by_name( "string" ) | -        |
| `Find All`        | Subject.all | Array of Objects |
| `Find first/last` | Subject.first | Object or nil |
| -                 | Subject.last | -              |




### *Query Methods*

#### *Query Methods: Conditions*

* String
  + `"name"='Test' AND visible=true"`
  + Flexible, raw SQL
  + Use carefully and beware of SQL injection
* Array
  + `[ "name=? AND visible=true", "Test" ]`
  + Flexible, escaped SQL and safe from SQL injection
* Hash
  + `{ :name => "Test", :visible => true }`
  + Simple, escaped SQL, and safe from SQL injection
  + Each key-value pair joined with AND
  + Supports value ranges (50..51, [1,3,5,7])
  + No OR, LIKE, less than, or greater than

* Returns an ActiveRelation, which can be chained

```ruby
User.where(:last_name => 'Smith')
    .where(:first_name => 'John')
```

#### *Query Methods: Order, Limit, and Offset*
* order(string)
* limit(integer)
* offset(integer)
  - `Subject.order(:position).limit(20).offset(40)`

```ruby
# Order Argument
# ==============
order(:position)        # default is ascending order
order("position")
order(:position => :asc)
order("position ASC")
order(:position => :desc)
order("position DESC")
```



### *Order SQL Table Disambiguation*
* Not necessary for single table
* Recommended with joined tables
* Required when joined tables have same column names
  + `order("subjects.created_at ASC")`
